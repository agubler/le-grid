(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/shim/WeakMap", "@dojo/shim/array", "@dojo/compose/bases/createEvented", "@dojo/core/lang"], factory);
    }
})(function (require, exports) {
    "use strict";
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var array_1 = require("@dojo/shim/array");
    var createEvented_1 = require("@dojo/compose/bases/createEvented");
    var lang_1 = require("@dojo/core/lang");
    /**
     * Private map for the widgets themeClasses.
     */
    var themeClassesMap = new WeakMap_1.default();
    function addClassNameToCSSModuleClassNames(cssModuleClassNames, classList, className) {
        if (classList.hasOwnProperty(className)) {
            // split out the classname because css-module composition combines class names with a space
            var generatedClassNames = classList[className].split(' ');
            generatedClassNames.forEach(function (generatedClassName) {
                cssModuleClassNames[generatedClassName] = true;
            });
        }
    }
    function negatePreviousClasses(previousClasses, newClasses) {
        return Object.keys(previousClasses).reduce(function (newAppliedClasses, className) {
            var oldCSSModuleClassNames = previousClasses[className];
            var negatedCSSModuleClassNames = Object.keys(oldCSSModuleClassNames).reduce(function (newCSSModuleClassNames, oldCSSModuleClassName) {
                var currentClassNameFlag = oldCSSModuleClassNames[oldCSSModuleClassName];
                // If it's true it needs to be negated and passed along, If it's false,
                // don't return it as maquette will already have removed it.
                if (currentClassNameFlag) {
                    newCSSModuleClassNames[oldCSSModuleClassName] = false;
                }
                return newCSSModuleClassNames;
            }, {});
            var calculatedClassNameMap = lang_1.assign({}, negatedCSSModuleClassNames, newClasses[className]);
            newAppliedClasses[className] = calculatedClassNameMap;
            return newAppliedClasses;
        }, {});
    }
    function generateThemeClasses(instance, baseTheme, theme, overrideClasses) {
        if (theme === void 0) { theme = {}; }
        if (overrideClasses === void 0) { overrideClasses = {}; }
        return Object.keys(baseTheme).reduce(function (newAppliedClasses, className) {
            var newCSSModuleClassNames = {};
            var themeClassSource = theme.hasOwnProperty(className) ? theme : baseTheme;
            addClassNameToCSSModuleClassNames(newCSSModuleClassNames, themeClassSource, className);
            overrideClasses && addClassNameToCSSModuleClassNames(newCSSModuleClassNames, overrideClasses, className);
            newAppliedClasses[className] = newCSSModuleClassNames;
            return newAppliedClasses;
        }, {});
    }
    function updateThemeClassesMap(instance, newThemeClasses) {
        if (themeClassesMap.has(instance)) {
            var previousThemeClasses = themeClassesMap.get(instance);
            themeClassesMap.set(instance, negatePreviousClasses(previousThemeClasses, newThemeClasses));
        }
        else {
            themeClassesMap.set(instance, newThemeClasses);
        }
    }
    function onPropertiesChanged(instance, _a, changedPropertyKeys) {
        var theme = _a.theme, overrideClasses = _a.overrideClasses;
        var themeChanged = array_1.includes(changedPropertyKeys, 'theme');
        var overrideClassesChanged = array_1.includes(changedPropertyKeys, 'overrideClasses');
        if (themeChanged || overrideClassesChanged) {
            var themeClasses = generateThemeClasses(instance, instance.baseTheme, theme, overrideClasses);
            updateThemeClassesMap(instance, themeClasses);
        }
    }
    /**
     * Themeable Factory
     */
    var themeableFactory = createEvented_1.default.mixin({
        mixin: {
            get theme() {
                return themeClassesMap.get(this);
            }
        },
        initialize: function (instance) {
            instance.own(instance.on('properties:changed', function (evt) {
                onPropertiesChanged(instance, evt.properties, evt.changedPropertyKeys);
            }));
            onPropertiesChanged(instance, instance.properties, ['theme']);
        }
    });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = themeableFactory;
});
//# sourceMappingURL=themeable.js.map