(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/shim/object", "@dojo/core/lang"], factory);
    }
})(function (require, exports) {
    "use strict";
    var object_1 = require("@dojo/shim/object");
    var lang_1 = require("@dojo/core/lang");
    /**
     * Determine if the value is an Object
     */
    function isObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]';
    }
    /**
     * Shallow comparison of all keys on the objects
     */
    function shallowCompare(from, to) {
        return Object.keys(from).every(function (key) { return from[key] === to[key]; });
    }
    /**
     * Mixin that overrides the `processProperties` method providing a comparison of attributes that goes a level deeper for
     * arrays and objects.
     *
     * For Objects, values for all `keys` are compared against the equivalent `key` on the `previousProperties`
     * attribute using `===`. If the `key` does not exists on the `previousProperties` attribute it is considered unequal.
     *
     * For Arrays, each `item` is compared with the `item` in the equivalent `index` of the `previousProperties` attribute.
     * If the `item` is an `object` then the object comparison described above is applied otherwise a simple `===` is used.
     */
    var shallowPropertyComparisonMixin = {
        mixin: {
            diffProperties: function (previousProperties, newProperties) {
                var changedKeys = [];
                object_1.entries(newProperties).forEach(function (_a) {
                    var key = _a[0], value = _a[1];
                    var isEqual = true;
                    if (previousProperties.hasOwnProperty(key)) {
                        var previousValue_1 = previousProperties[key];
                        if (Array.isArray(value) && Array.isArray(previousValue_1)) {
                            if (value.length !== previousValue_1.length) {
                                isEqual = false;
                            }
                            else {
                                isEqual = value.every(function (item, index) {
                                    if (isObject(item)) {
                                        return shallowCompare(item, previousValue_1[index]);
                                    }
                                    else {
                                        return item === previousValue_1[index];
                                    }
                                });
                            }
                        }
                        else if (isObject(value) && isObject(previousValue_1)) {
                            isEqual = shallowCompare(value, previousValue_1);
                        }
                        else {
                            isEqual = value === previousValue_1;
                        }
                    }
                    else {
                        isEqual = false;
                    }
                    if (!isEqual) {
                        changedKeys.push(key);
                    }
                });
                return {
                    changedKeys: changedKeys,
                    properties: lang_1.deepAssign({}, newProperties)
                };
            }
        }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = shallowPropertyComparisonMixin;
});
//# sourceMappingURL=shallowPropertyComparisonMixin.js.map