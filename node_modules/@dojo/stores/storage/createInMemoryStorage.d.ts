import { Query } from '../query/interfaces';
import { CrudOptions, StoreOptions, UpdateResults } from '../store/createStore';
import { ComposeFactory } from '@dojo/compose/compose';
import Promise from '@dojo/shim/Promise';
import Map from '@dojo/shim/Map';
import { Patch } from '../patch/createPatch';
export interface FetchResult<T> extends Promise<T[]> {
    /**
     * A Promise that resolves to the total number of items in the underlying storage.
     */
    totalLength: Promise<number>;
    /**
     * For a store, this is identical to totalLength. For a QueryTransformResult, this resolves to the number of items
     * that match the QueryTransformResult's queries
     */
    dataLength: Promise<number>;
}
export interface Storage<T, O extends CrudOptions> {
    identify(items: T[] | T): string[];
    createId(): Promise<string>;
    fetch(query?: Query<T>): FetchResult<T>;
    get(ids: string[]): Promise<T[]>;
    put(items: T[], options?: O): Promise<UpdateResults<T>>;
    add(items: T[], options?: O): Promise<UpdateResults<T>>;
    delete(ids: string[]): Promise<UpdateResults<T>>;
    patch(updates: {
        id: string;
        patch: Patch<T, T>;
    }[], options?: O): Promise<UpdateResults<T>>;
    isUpdate(item: T): Promise<{
        isUpdate: boolean;
        item: T;
        id: string;
    }>;
}
export interface InMemoryStorageState<T> {
    idProperty?: string;
    idFunction?: (item: T) => string;
    data: T[];
    index: Map<string, number>;
    returnsPromise: Promise<any>;
}
export interface StorageFactory extends ComposeFactory<Storage<{}, {}>, StoreOptions<{}, CrudOptions>> {
    <T extends {}, O extends CrudOptions>(options?: O): Storage<T, O>;
}
export interface InMemoryStorageFactory extends StorageFactory {
    <T>(options?: StoreOptions<T, CrudOptions>): Storage<T, CrudOptions>;
}
declare const createInMemoryStorage: InMemoryStorageFactory;
export default createInMemoryStorage;
