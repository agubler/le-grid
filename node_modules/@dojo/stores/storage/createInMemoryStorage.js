(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/compose/compose", "@dojo/shim/Promise", "@dojo/shim/WeakMap", "@dojo/shim/Map", "@dojo/core/lang", "@dojo/core/uuid"], factory);
    }
})(function (require, exports) {
    "use strict";
    var compose_1 = require("@dojo/compose/compose");
    var Promise_1 = require("@dojo/shim/Promise");
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var Map_1 = require("@dojo/shim/Map");
    var lang_1 = require("@dojo/core/lang");
    var uuid_1 = require("@dojo/core/uuid");
    var instanceStateMap = new WeakMap_1.default();
    function putSync(instance, items, options) {
        var state = instanceStateMap.get(instance);
        var ids = instance.identify(items);
        var updatedItems = [];
        var oldIndices = [];
        var newIds = [];
        var newItems = [];
        ids.forEach(function (id, index) {
            var oldIndex = state.index.get(id);
            if (typeof oldIndex === 'undefined') {
                newIds.push(id);
                newItems.push(items[index]);
            }
            else {
                updatedItems.push(items[index]);
                oldIndices.push(oldIndex);
            }
        });
        if (oldIndices.length && options && options.rejectOverwrite) {
            throw Error('Objects already exist in store');
        }
        var data = state.data;
        updatedItems.forEach(function (item, index) {
            data[oldIndices[index]] = item;
        });
        newItems.forEach(function (item, index) {
            state.index.set(newIds[index], data.push(item) - 1);
        });
        return {
            successfulData: items,
            type: 1 /* Put */
        };
    }
    var createInMemoryStorage = compose_1.default({
        identify: function (items) {
            var state = instanceStateMap.get(this);
            var itemArray = Array.isArray(items) ? items : [items];
            if (state.idProperty) {
                var idProperty_1 = state.idProperty;
                return itemArray.map(function (item) {
                    return item[idProperty_1];
                });
            }
            else if (state.idFunction) {
                return itemArray.map(state.idFunction);
            }
            else {
                return itemArray.map(function (item) {
                    return item.id;
                });
            }
        },
        createId: function () {
            return Promise_1.default.resolve(uuid_1.default());
        },
        fetch: function (query) {
            var state = instanceStateMap.get(this);
            var fullData = state.data;
            var data = (query ? query.apply(fullData) : fullData).slice();
            var returnPromise = state.returnsPromise.then(function () { return data; });
            state.returnsPromise = returnPromise;
            returnPromise.totalLength = returnPromise.dataLength = Promise_1.default.resolve(fullData.length);
            return returnPromise;
        },
        get: function (ids) {
            var state = instanceStateMap.get(this);
            var data = state.data;
            var objects = [];
            return Promise_1.default.resolve(ids.reduce(function (prev, next) {
                return state.index.has(next) ? prev.concat(data[state.index.get(next)]) : prev;
            }, objects));
        },
        put: function (items, options) {
            var state = instanceStateMap.get(this);
            try {
                var result_1 = putSync(this, items, options);
                // Don't control the order operations are executed in, but make sure that the results
                // resolve in the order they were actually executed in.
                var returnPromise = state.returnsPromise.then(function () { return result_1; });
                state.returnsPromise = returnPromise;
                return returnPromise;
            }
            catch (error) {
                return Promise_1.default.reject(error);
            }
        },
        add: function (items, options) {
            options = options || {};
            var state = instanceStateMap.get(this);
            if (typeof options.rejectOverwrite === 'undefined') {
                options.rejectOverwrite = true;
            }
            try {
                var result_2 = putSync(this, items, options);
                // Don't control the order operations are executed in, but make sure that the results
                // resolve in the order they were actually executed in.
                var returnPromise = state.returnsPromise.then(function () {
                    result_2.type = 0 /* Add */;
                    return result_2;
                });
                state.returnsPromise = returnPromise;
                return returnPromise;
            }
            catch (error) {
                return Promise_1.default.reject(error);
            }
        },
        delete: function (ids) {
            var state = instanceStateMap.get(this);
            var data = state.data;
            var idsToRemove = ids.filter(function (id) {
                return state.index.has(id);
            });
            var indices = idsToRemove
                .map(function (id) {
                return state.index.get(id);
            })
                .sort();
            idsToRemove.forEach(function (id) {
                state.index.delete(id);
            });
            indices.forEach(function (index, indexArrayIndex) {
                return data.splice(index - indexArrayIndex, 1);
            });
            if (indices.length) {
                var firstInvalidIndex_1 = indices[0];
                var updateIndexForIds = this.identify(data.slice(firstInvalidIndex_1));
                updateIndexForIds.forEach(function (id, index) {
                    state.index.set(id, index + firstInvalidIndex_1);
                });
            }
            // Don't control the order operations are executed in, but make sure that the results
            // resolve in the order they were actually executed in.
            var returnPromise = state.returnsPromise.then(function () { return ({
                successfulData: idsToRemove,
                type: 3 /* Delete */
            }); });
            state.returnsPromise = returnPromise;
            return returnPromise;
        },
        patch: function (updates) {
            var state = instanceStateMap.get(this);
            var data = state.data;
            var filteredUpdates = updates.filter(function (update) {
                return state.index.has(update.id);
            });
            var oldIndices = filteredUpdates.map(function (update) {
                return state.index.get(update.id);
            });
            try {
                var updatedItems_1 = filteredUpdates.map(function (update, index) {
                    var item = lang_1.duplicate(data[oldIndices[index]]);
                    var updatedItem = update.patch.apply(item);
                    data[oldIndices[index]] = updatedItem;
                    return updatedItem;
                });
                // Don't control the order operations are executed in, but make sure that the results
                // resolve in the order they were actually executed in.
                var returnsPromise = state.returnsPromise.then(function () { return ({
                    successfulData: updatedItems_1,
                    type: 2 /* Patch */
                }); });
                state.returnsPromise = returnsPromise;
                return returnsPromise;
            }
            catch (error) {
                return Promise_1.default.reject(error);
            }
        },
        isUpdate: function (item) {
            var state = instanceStateMap.get(this);
            var id = this.identify([item])[0];
            var isUpdate = state.index.has(id);
            return Promise_1.default.resolve({
                id: id,
                item: item,
                isUpdate: isUpdate
            });
        }
    }, function (instance, options) {
        options = options || {};
        instanceStateMap.set(instance, {
            data: [],
            index: new Map_1.default(),
            idProperty: options.idProperty,
            idFunction: options.idFunction,
            returnsPromise: Promise_1.default.resolve()
        });
    });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createInMemoryStorage;
});
//# sourceMappingURL=createInMemoryStorage.js.map