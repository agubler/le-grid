{"version":3,"file":"createInMemoryStorage.js","sourceRoot":"","sources":["createInMemoryStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import { Query } from '../query/interfaces';\nimport { StoreOperation, CrudOptions, StoreOptions, UpdateResults } from '../store/createStore';\nimport compose, { ComposeFactory } from '@dojo/compose/compose';\nimport Promise from '@dojo/shim/Promise';\nimport WeakMap from '@dojo/shim/WeakMap';\nimport Map from '@dojo/shim/Map';\nimport { Patch } from '../patch/createPatch';\nimport { duplicate } from '@dojo/core/lang';\nimport uuid from '@dojo/core/uuid';\n\nexport interface FetchResult<T> extends Promise<T[]> {\n\t/**\n\t * A Promise that resolves to the total number of items in the underlying storage.\n\t */\n\ttotalLength: Promise<number>;\n\t/**\n\t * For a store, this is identical to totalLength. For a QueryTransformResult, this resolves to the number of items\n\t * that match the QueryTransformResult's queries\n\t */\n\tdataLength: Promise<number>;\n}\n\nexport interface Storage<T, O extends CrudOptions> {\n\tidentify(items: T[]|T): string[];\n\tcreateId(): Promise<string>;\n\tfetch(query?: Query<T>): FetchResult<T>;\n\tget(ids: string[]): Promise<T[]>;\n\tput(items: T[], options?: O): Promise<UpdateResults<T>>;\n\tadd(items: T[], options?: O): Promise<UpdateResults<T>>;\n\tdelete(ids: string[]): Promise<UpdateResults<T>>;\n\tpatch(updates: { id: string; patch: Patch<T, T> }[], options?: O): Promise<UpdateResults<T>>;\n\tisUpdate(item: T): Promise<{ isUpdate: boolean; item: T, id: string }>;\n}\n\nexport interface InMemoryStorageState<T> {\n\tidProperty?: string;\n\tidFunction?: (item: T) => string;\n\tdata: T[];\n\tindex: Map<string, number>;\n\treturnsPromise: Promise<any>;\n}\n\nconst instanceStateMap = new WeakMap<Storage<{}, {}>, InMemoryStorageState<{}>>();\n\nexport interface StorageFactory extends ComposeFactory<Storage<{}, {}>, StoreOptions<{}, CrudOptions>> {\n\t<T extends {}, O extends CrudOptions>(options?: O): Storage<T, O>;\n}\n\nexport interface InMemoryStorageFactory extends StorageFactory {\n\t<T>(options?: StoreOptions<T, CrudOptions>): Storage<T, CrudOptions>;\n}\n\ntype IdObject = { [ index: string ]: string; id: string };\n\nfunction putSync(instance: Storage<{}, {}>, items: {}[], options?: CrudOptions) {\n\tconst state = instanceStateMap.get(instance);\n\tconst ids = instance.identify(items);\n\n\tconst updatedItems: {}[] = [];\n\tconst oldIndices: number[] = [];\n\tconst newIds: string[] = [];\n\tconst newItems: {}[] = [];\n\n\tids.forEach(function(id, index) {\n\t\tconst oldIndex = state.index.get(id);\n\t\tif (typeof oldIndex === 'undefined') {\n\t\t\tnewIds.push(id);\n\t\t\tnewItems.push(items[index]);\n\t\t}\n\t\telse {\n\t\t\tupdatedItems.push(items[index]);\n\t\t\toldIndices.push(oldIndex);\n\t\t}\n\t});\n\tif (oldIndices.length && options && options.rejectOverwrite) {\n\t\tthrow Error('Objects already exist in store');\n\t}\n\n\tconst data = state.data;\n\tupdatedItems.forEach(function(item, index) {\n\t\tdata[oldIndices[index]] = item;\n\t});\n\tnewItems.forEach(function(item, index) {\n\t\tstate.index.set(newIds[index], data.push(item) - 1);\n\t});\n\treturn {\n\t\tsuccessfulData: items,\n\t\ttype: StoreOperation.Put\n\t};\n}\n\nconst createInMemoryStorage: InMemoryStorageFactory = compose<Storage<IdObject, CrudOptions>, StoreOptions<{}, CrudOptions>>({\n\tidentify(this: Storage<{}, {}>, items: IdObject[]| IdObject): string[] {\n\t\tconst state = instanceStateMap.get(this);\n\t\tconst itemArray = Array.isArray(items) ? <IdObject []> items : [ <IdObject> items ];\n\t\tif (state.idProperty) {\n\t\t\tconst idProperty: string = state.idProperty;\n\t\t\treturn itemArray.map((item) => {\n\t\t\t\treturn item[idProperty];\n\t\t\t});\n\t\t}\n\t\telse if (state.idFunction) {\n\t\t\treturn itemArray.map(state.idFunction);\n\t\t}\n\t\telse {\n\t\t\treturn itemArray.map(function(item) {\n\t\t\t\treturn item.id;\n\t\t\t});\n\t\t}\n\t},\n\n\tcreateId(this: Storage<{}, {}>): Promise<string> {\n\t\treturn Promise.resolve(uuid());\n\t},\n\n\tfetch(this: Storage<{}, {}>, query?: Query<{}>): FetchResult<{}> {\n\t\tconst state = instanceStateMap.get(this);\n\t\tconst fullData = state.data;\n\t\tconst data = (query ? query.apply(fullData) : fullData).slice();\n\t\tconst returnPromise = state.returnsPromise.then(() => data);\n\t\tstate.returnsPromise = returnPromise;\n\t\t(<any> returnPromise).totalLength = (<any> returnPromise).dataLength = Promise.resolve(fullData.length);\n\t\treturn returnPromise as FetchResult<{}>;\n\t},\n\n\tget(this: Storage<{}, {}>, ids: string[]): Promise<{}[]> {\n\t\tconst state = instanceStateMap.get(this);\n\t\tconst data = state.data;\n\t\tconst objects: {}[] = [];\n\t\treturn Promise.resolve(ids.reduce(function(prev, next) {\n\t\t\treturn state.index.has(next) ? prev.concat( data[state.index.get(next)!] ) : prev;\n\t\t}, objects));\n\t},\n\n\tput(this: Storage<{}, {}>, items: {}[], options?: CrudOptions): Promise<UpdateResults<{}>> {\n\t\tconst state = instanceStateMap.get(this);\n\t\ttry {\n\t\t\tconst result = putSync(this, items, options);\n\t\t\t// Don't control the order operations are executed in, but make sure that the results\n\t\t\t// resolve in the order they were actually executed in.\n\t\t\tconst returnPromise = state.returnsPromise.then(() => result);\n\t\t\tstate.returnsPromise = returnPromise;\n\t\t\treturn returnPromise;\n\t\t} catch (error) {\n\t\t\treturn Promise.reject(error);\n\t\t}\n\t},\n\n\tadd(this: Storage<{}, {}>, items: {}[], options?: CrudOptions): Promise<UpdateResults<{}>> {\n\t\toptions = options || {};\n\t\tconst state = instanceStateMap.get(this);\n\t\tif (typeof options.rejectOverwrite === 'undefined') {\n\t\t\toptions.rejectOverwrite = true;\n\t\t}\n\n\t\ttry {\n\t\t\tconst result = putSync(this, items, options);\n\t\t\t// Don't control the order operations are executed in, but make sure that the results\n\t\t\t// resolve in the order they were actually executed in.\n\t\t\tconst returnPromise = state.returnsPromise.then(() => {\n\t\t\t\tresult.type = StoreOperation.Add;\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\tstate.returnsPromise = returnPromise;\n\t\t\treturn returnPromise;\n\t\t} catch (error) {\n\t\t\treturn Promise.reject(error);\n\t\t}\n\t},\n\n\tdelete(this: Storage<{}, {}>, ids: string[]): Promise<UpdateResults<{}>> {\n\t\tconst state = instanceStateMap.get(this);\n\t\tconst data = state.data;\n\t\tconst idsToRemove = ids.filter(function(id) {\n\t\t\treturn state.index.has(id);\n\t\t});\n\n\t\tconst indices: number[] = idsToRemove\n\t\t\t.map(function(id) {\n\t\t\t\treturn state.index.get(id)!;\n\t\t\t})\n\t\t\t.sort();\n\n\t\tidsToRemove.forEach(function(id) {\n\t\t\tstate.index.delete(id);\n\t\t});\n\t\tindices.forEach(function(index, indexArrayIndex) {\n\t\t\treturn data.splice(index - indexArrayIndex, 1);\n\t\t});\n\t\tif (indices.length) {\n\t\t\tconst firstInvalidIndex = indices[0];\n\t\t\tconst updateIndexForIds = this.identify(data.slice(firstInvalidIndex));\n\t\t\tupdateIndexForIds.forEach(function(id, index) {\n\t\t\t\tstate.index.set(id, index + firstInvalidIndex);\n\t\t\t});\n\t\t}\n\n\t\t// Don't control the order operations are executed in, but make sure that the results\n\t\t// resolve in the order they were actually executed in.\n\t\tconst returnPromise = state.returnsPromise.then(() => ({\n\t\t\tsuccessfulData: idsToRemove,\n\t\t\ttype: StoreOperation.Delete\n\t\t}));\n\t\tstate.returnsPromise = returnPromise;\n\t\treturn returnPromise;\n\t},\n\n\tpatch(this: Storage<{}, {}>, updates: { id: string; patch: Patch<{}, {}> }[]): Promise<UpdateResults<{}>> {\n\t\tconst state = instanceStateMap.get(this);\n\t\tconst data = state.data;\n\n\t\tconst filteredUpdates = updates.filter(function(update) {\n\t\t\treturn state.index.has(update.id);\n\t\t});\n\t\tconst oldIndices = filteredUpdates.map(function(update) {\n\t\t\treturn state.index.get(update.id)!;\n\t\t});\n\n\t\ttry {\n\t\t\tconst updatedItems = filteredUpdates.map(function(update, index) {\n\t\t\t\tconst item = duplicate(data[oldIndices[index]]);\n\t\t\t\tconst updatedItem = update.patch.apply(item);\n\t\t\t\tdata[oldIndices[index]] = updatedItem;\n\t\t\t\treturn updatedItem;\n\t\t\t});\n\t\t\t// Don't control the order operations are executed in, but make sure that the results\n\t\t\t// resolve in the order they were actually executed in.\n\t\t\tconst returnsPromise = state.returnsPromise.then(() => ({\n\t\t\t\tsuccessfulData: updatedItems,\n\t\t\t\ttype: StoreOperation.Patch\n\t\t\t}));\n\t\t\tstate.returnsPromise = returnsPromise;\n\t\t\treturn returnsPromise;\n\t\t} catch (error) {\n\t\t\treturn Promise.reject(error);\n\t\t}\n\t},\n\n\tisUpdate(this: Storage<{}, {}>, item: {}): Promise<{ isUpdate: boolean; item: {}; id: string }> {\n\t\tconst state = instanceStateMap.get(this);\n\t\tconst id = this.identify([ item ])[0];\n\t\tconst isUpdate = state.index.has(id);\n\t\treturn Promise.resolve({\n\t\t\tid: id,\n\t\t\titem: item,\n\t\t\tisUpdate: isUpdate\n\t\t});\n\t}\n}, <T, O>(instance: Storage<T, O>, options?: StoreOptions<T, CrudOptions>) => {\n\toptions = options || {};\n\tinstanceStateMap.set(instance, {\n\t\tdata: [],\n\t\tindex: new Map<string, number>(),\n\t\tidProperty: options.idProperty,\n\t\tidFunction: options.idFunction,\n\t\treturnsPromise: Promise.resolve()\n\t});\n});\n\nexport default createInMemoryStorage;\n"]}