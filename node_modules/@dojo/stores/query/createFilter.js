(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../patch/createJsonPointer", "../utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    var createJsonPointer_1 = require("../patch/createJsonPointer");
    var utils_1 = require("../utils");
    function isBooleanOp(op) {
        return op === 0 /* And */ || op === 1 /* Or */;
    }
    function isFilter(filterOrFunction) {
        return typeof filterOrFunction !== 'function' && filterOrFunction.apply;
    }
    function createFilterOrReturnOp(descriptorOrOp) {
        if (isBooleanOp(descriptorOrOp)) {
            return descriptorOrOp;
        }
        else {
            return createComparator(descriptorOrOp.filterType, descriptorOrOp.value, descriptorOrOp.path);
        }
    }
    function createFilter(filterDescriptors, serializer) {
        var filters = [];
        if (filterDescriptors) {
            if (Array.isArray(filterDescriptors)) {
                filters = filterDescriptors.map(function (descriptorChainMember) {
                    if (Array.isArray(descriptorChainMember)) {
                        return createFilter(descriptorChainMember);
                    }
                    else {
                        return createFilterOrReturnOp(descriptorChainMember);
                    }
                });
            }
            else {
                filters.push(createComparator(filterDescriptors.filterType, filterDescriptors.value, filterDescriptors.path));
            }
        }
        return createFilterHelper(filters, serializer || serializeFilter);
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createFilter;
    function createFilterHelper(filters, serializer) {
        // Small helpers to abstract common operations for building comparator filters
        // The main helper delegates to the factory, adding and AND operation before the next filter,
        // because by default each filter in a chain will be ANDed with the previous.
        function comparatorFilterHelper(filterType, value, path) {
            path = path || createJsonPointer_1.default();
            var needsOperator = filters.length > 0 &&
                (filters[filters.length - 1] !== 0 /* And */ && filters[filters.length - 1] !== 1 /* Or */);
            var newFilters = needsOperator ? filters.concat([0 /* And */, createComparator(filterType, value, path)]) : filters.concat([createComparator(filterType, value, path)]);
            return createFilterHelper(newFilters, serializer);
        }
        var filter = {
            test: function (item) {
                return applyFilterChain(item, filters);
            },
            filterType: 12 /* Compound */,
            apply: function (data) {
                return data.filter(this.test);
            },
            filterChain: filters,
            toString: function (filterSerializer) {
                return (filterSerializer || serializer)(this);
            },
            and: function (newFilter) {
                var newFilters = [];
                if (newFilter) {
                    newFilters.push(this, 0 /* And */, newFilter);
                }
                else if (filters.length) {
                    newFilters.push.apply(newFilters, filters.concat([0 /* And */]));
                }
                return createFilterHelper(newFilters, serializer);
            },
            or: function (newFilter) {
                var newFilters = [];
                if (newFilter) {
                    newFilters.push(this, 1 /* Or */, newFilter);
                }
                else if (filters.length) {
                    newFilters.push.apply(newFilters, filters.concat([1 /* Or */]));
                }
                return createFilterHelper(newFilters, serializer);
            },
            lessThan: function (path, value) {
                return comparatorFilterHelper(0 /* LessThan */, value, path);
            },
            lessThanOrEqualTo: function (path, value) {
                return comparatorFilterHelper(8 /* LessThanOrEqualTo */, value, path);
            },
            greaterThan: function (path, value) {
                return comparatorFilterHelper(1 /* GreaterThan */, value, path);
            },
            greaterThanOrEqualTo: function (path, value) {
                return comparatorFilterHelper(9 /* GreaterThanOrEqualTo */, value, path);
            },
            matches: function (path, value) {
                return comparatorFilterHelper(10 /* Matches */, value, path);
            },
            'in': function (path, value) {
                return comparatorFilterHelper(4 /* In */, value, path);
            },
            contains: function (path, value) {
                return comparatorFilterHelper(5 /* Contains */, value, path);
            },
            equalTo: function (path, value) {
                return comparatorFilterHelper(2 /* EqualTo */, value, path);
            },
            deepEqualTo: function (path, value) {
                return comparatorFilterHelper(3 /* DeepEqualTo */, value, path);
            },
            notEqualTo: function (path, value) {
                return comparatorFilterHelper(6 /* NotEqualTo */, value, path);
            },
            notDeepEqualTo: function (path, value) {
                return comparatorFilterHelper(7 /* NotDeepEqualTo */, value, path);
            },
            custom: function (test) {
                return comparatorFilterHelper(11 /* Custom */, test);
            },
            queryType: 0 /* Filter */,
            incremental: true
        };
        return filter;
    }
    function applyFilterChain(item, filterChain) {
        var ordFilterSections = [];
        var startOfSlice = 0;
        // Ands have higher precedence, so split into chains of
        // ands between ors.
        filterChain.forEach(function (chainMember, i) {
            if (chainMember === 1 /* Or */) {
                ordFilterSections.push(filterChain.slice(startOfSlice, i));
                startOfSlice = i + 1;
            }
        });
        if (startOfSlice < filterChain.length) {
            ordFilterSections.push(filterChain.slice(startOfSlice, filterChain.length));
        }
        // These sections are or'd together so only
        // one has to pass
        return ordFilterSections.some(function (filterChain) {
            // The individual filters are and'd together, so if any
            // fails the whole section fails
            return filterChain.every(function (filterOrAnd) {
                if (isFilter(filterOrAnd)) {
                    return filterOrAnd.test(item);
                }
                else {
                    return true;
                }
            });
        });
    }
    function createComparator(operator, value, path) {
        path = typeof path === 'string' ? createJsonPointer_1.default(path) : path;
        var test;
        var filterType = operator;
        var operatorString;
        switch (operator) {
            case 0 /* LessThan */:
                test = function (property) {
                    return property < value;
                };
                operatorString = 'lt';
                break;
            case 8 /* LessThanOrEqualTo */:
                test = function (property) {
                    return property <= value;
                };
                operatorString = 'lte';
                break;
            case 1 /* GreaterThan */:
                test = function (property) {
                    return property > value;
                };
                operatorString = 'gt';
                break;
            case 9 /* GreaterThanOrEqualTo */:
                test = function (property) {
                    return property >= value;
                };
                operatorString = 'gte';
                break;
            case 2 /* EqualTo */:
                test = function (property) {
                    return property === value;
                };
                operatorString = 'eq';
                break;
            case 6 /* NotEqualTo */:
                test = function (property) {
                    return property !== value;
                };
                operatorString = 'ne';
                break;
            case 3 /* DeepEqualTo */:
                test = function (property) {
                    return utils_1.isEqual(property, value);
                };
                operatorString = 'eq';
                break;
            case 7 /* NotDeepEqualTo */:
                test = function (property) {
                    return !utils_1.isEqual(property, value);
                };
                operatorString = 'ne';
                break;
            case 5 /* Contains */:
                test = function (propertyOrItem) {
                    if (Array.isArray(propertyOrItem)) {
                        return propertyOrItem.indexOf(value) > -1;
                    }
                    else {
                        return propertyOrItem && Boolean(propertyOrItem[value]);
                    }
                };
                operatorString = 'contains';
                break;
            case 4 /* In */:
                test = function (propertyOrItem) {
                    return Array.isArray(value) && value.indexOf(propertyOrItem) > -1;
                };
                operatorString = 'in';
                break;
            case 10 /* Matches */:
                test = function (property) {
                    return value.test(property);
                };
                break;
            case 11 /* Custom */:
                test = value;
                break;
        }
        return {
            test: function (item) {
                var propertyValue = createJsonPointer_1.navigate(path, item);
                return test(propertyValue);
            },
            apply: function (data) {
                return data.filter(this.test);
            },
            toString: function () {
                if (!operatorString) {
                    throw Error('Cannot parse this filter type to an RQL query string');
                }
                return operatorString + "(" + path.toString() + ", " + JSON.stringify(value) + ")";
            },
            path: path,
            value: value,
            filterType: filterType,
            queryType: 0 /* Filter */
        };
    }
    //// Default serialization function
    function serializeFilter(filter) {
        var operator = '&';
        if (filter.filterChain && filter.filterChain.length > 0) {
            return filter.filterChain.reduce(function (prev, next) {
                if (isFilter(next)) {
                    var start = next.filterChain ? '(' : '';
                    var end = next.filterChain ? ')' : '';
                    return prev + (prev ? operator : '') + (prev ? start : '') + next.toString() + (prev ? end : '');
                }
                else if (next === 0 /* And */) {
                    operator = '&';
                    return prev;
                }
                else {
                    operator = '|';
                    return prev;
                }
            }, '');
        }
        else {
            return '';
        }
    }
});
//# sourceMappingURL=createFilter.js.map