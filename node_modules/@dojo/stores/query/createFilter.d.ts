import { JsonPointer } from '../patch/createJsonPointer';
import { Query } from './interfaces';
export declare type FilterFunction<T> = (data: T[]) => T[];
export declare type ObjectPointer = JsonPointer | string;
export declare const enum FilterType {
    LessThan = 0,
    GreaterThan = 1,
    EqualTo = 2,
    DeepEqualTo = 3,
    In = 4,
    Contains = 5,
    NotEqualTo = 6,
    NotDeepEqualTo = 7,
    LessThanOrEqualTo = 8,
    GreaterThanOrEqualTo = 9,
    Matches = 10,
    Custom = 11,
    Compound = 12,
}
export declare const enum BooleanOp {
    And = 0,
    Or = 1,
}
export declare type FilterChainMember<T> = SimpleFilter<T> | BooleanOp;
export interface FilterDescriptor {
    readonly filterType: FilterType;
    readonly path: ObjectPointer;
    readonly value: any;
}
export declare type FilterArrayEntry = FilterDescriptor | BooleanOp | FilterArray;
export interface FilterArray extends Array<FilterArrayEntry> {
}
export interface SimpleFilter<T> extends Query<T> {
    readonly filterType: FilterType;
    readonly test: (item: T) => boolean;
    readonly filterChain?: FilterChainMember<T>[];
    readonly path?: ObjectPointer;
    readonly value?: any;
}
export interface BooleanFilter<T> extends SimpleFilter<T> {
    lessThan(path: ObjectPointer, value: number): Filter<T>;
    lessThanOrEqualTo(path: ObjectPointer, value: number): Filter<T>;
    greaterThan(path: ObjectPointer, value: number): Filter<T>;
    greaterThanOrEqualTo(path: ObjectPointer, value: number): Filter<T>;
    matches(path: ObjectPointer, test: RegExp): Filter<T>;
    in<U>(path: ObjectPointer, value: U[]): Filter<T>;
    contains<U>(path: ObjectPointer, value: U): Filter<T>;
    equalTo<U>(path: ObjectPointer, value: U): Filter<T>;
    deepEqualTo<U extends {}>(path: ObjectPointer, value: U): Filter<T>;
    deepEqualTo<U>(path: ObjectPointer, value: U[]): Filter<T>;
    notEqualTo<U>(path: ObjectPointer, value: U): Filter<T>;
    notDeepEqualTo<U extends {}>(path: ObjectPointer, value: U): Filter<T>;
    notDeepEqualTo<U>(path: ObjectPointer, value: U[]): Filter<T>;
    custom(test: (item: T) => boolean): Filter<T>;
}
export interface Filter<T> extends BooleanFilter<T> {
    and(filter: Filter<T>): Filter<T>;
    and(): BooleanFilter<T>;
    or(filter: Filter<T>): Filter<T>;
    or(): BooleanFilter<T>;
}
declare function createFilter<T>(filterDescriptors?: FilterDescriptor | FilterArray, serializer?: (filter: Filter<T>) => string): Filter<T>;
export default createFilter;
