{"version":3,"file":"createQueryTransformResult.js","sourceRoot":"","sources":["createQueryTransformResult.ts"],"names":[],"mappings":"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","sourcesContent":["import { ObservableStore, ItemUpdate, StoreDelta, mergeDeltas, buildIndex } from './mixins/createObservableStoreMixin';\nimport { Query, QueryType } from '../query/interfaces';\nimport { Observable, Observer } from '@dojo/core/Observable';\nimport { Patch } from '../patch/createPatch';\nimport compose, { ComposeFactory } from '@dojo/compose/compose';\nimport createFilter, { Filter } from '../query/createFilter';\nimport createRange, { StoreRange } from '../query/createStoreRange';\nimport createSort, { Sort } from '../query/createSort';\nimport createCompoundQuery from '../query/createCompoundQuery';\nimport Promise from '@dojo/shim/Promise';\nimport Map from '@dojo/shim/Map';\nimport Set from '@dojo/shim/Set';\nimport WeakMap from '@dojo/shim/WeakMap';\nimport { debounce } from '@dojo/core/util';\nimport { isFilter, isSort, QueryTransformMixin } from './mixins/createQueryTransformMixin';\nimport { FetchResult } from '../storage/createInMemoryStorage';\n\nexport interface TrackableStoreDelta<T> extends StoreDelta<T> {\n\t/**\n\t * Contains info for any items that were formerly in the tracked collection and are now not, regardless of how\n\t * those items were removed\n\t */\n\tremovedFromTracked: { item: T; id: string; previousIndex: number; }[];\n\t/**\n\t * Contains info for any items that are now in the tracked collection and formerly were not, regardless of how\n\t * those items were added\n\t */\n\taddedToTracked: { item: T; id: string; index: number; }[];\n\t/**\n\t * Contains info were previously and still are in the tracked collection but have changed position, regardless of\n\t * how the items were moved.\n\t */\n\tmovedInTracked: { item: T; id: string; previousIndex: number; index: number }[];\n}\n\n/**\n * Checks if this is a tracked update or not\n * @param storeDelta\n * @returns {Boolean}\n */\nfunction isTracked<T>(storeDelta: StoreDelta<T>): storeDelta is TrackableStoreDelta<T> {\n\tconst tracked = <TrackableStoreDelta<T>> storeDelta;\n\treturn Boolean(tracked.removedFromTracked || tracked.addedToTracked || tracked.movedInTracked);\n}\n\n/**\n * Describes a transformation\n */\nexport type TransformationDescriptor<T, F> = {\n\ttransformation: Patch<F, T> | ((item: F) => T);  idTransform?: string | ((item: T) => string)\n};\n\n/**\n * If this function is 'mapped'(Items can be identified), and it contains only transformations and incremental queries,\n * then we can update it in place, assuming that we are notified about all changes and are starting from the correct\n * data.\n * @param queriesAndTransforms\n * @param result\n * @returns {boolean|boolean}\n */\nfunction canUpdateInPlace(\n\tqueriesAndTransforms: Array<Query<any> | TransformationDescriptor<any, any>>,\n\tresult: QueryTransformResult<any, any>\n) {\n\treturn isMapped(result) && queriesAndTransforms.every((queryOrTransformation) =>\n\t\t!isQuery(queryOrTransformation) || Boolean(queryOrTransformation.incremental)\n\t);\n}\n\nexport interface QueryTransformState<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> {\n\t/**\n\t * Queries and transformations for this query transform result\n\t */\n\tqueriesAndTransformations: Array<Query<any> | TransformationDescriptor<any, any>>;\n\t/**\n\t * Tracks whether we can modify the local collection in place or need to fetch to get the correct state after an\n\t * update\n\t */\n\tcanUpdateInPlace: boolean;\n\t/**\n\t * Tracks whether we're tracking this collection\n\t */\n\tisTracking?: boolean;\n\t/**\n\t * Optional value that indicates the amount of time to debounce the fetch called after receiving an update.\n\t */\n\ttrackingFetchDelay?: number;\n\t/**\n\t * A debounced function that just delegates to the instance's fetch method\n\t * @param instance\n\t */\n\tfetchAndSendUpdates: (instance: QueryTransformResult<T, S>) => void;\n\t/**\n\t * The store this query transform result comes from\n\t */\n\tsource: S;\n\t/**\n\t * The observable that observers of this query transform result will be provided\n\t */\n\tobservable: Observable<StoreDelta<T>>;\n\t/**\n\t * Observers of this query transform result\n\t */\n\tobservers: Observer<StoreDelta<T>>[];\n\t/**\n\t * The local copy of the data for this view\n\t */\n\tlocalData: T[];\n\t/**\n\t * Updates ready to be send after the next fetch\n\t */\n\tqueuedUpdate?: StoreDelta<T>;\n\t/**\n\t * Keeps track of new item IDs as updates are being queued\n\t */\n\tcurrentUpdateIndex: Set<string>;\n\t/**\n\t * Promise tracking the initial fetch if we are tracking and are not fetchingAroundUpdates\n\t */\n\tinitialFetch?: Promise<T[]>;\n\t/**\n\t * Is the parent store fetching around updates\n\t * If the parent store is fetching around updates, we will always have the latest superset of this view's data in\n\t * the updates it receives locally. In that case, even if actively tracking, no additional fetches need to be\n\t * performed, the local queries and transformations can just be applied to the new data directly.\n\t */\n\tfetchAroundUpdates: boolean;\n\t/**\n\t * Maps IDs to indices in localDAta\n\t */\n\tlocalIndex: Map<string, number>;\n\n\t/**\n\t * Handle to the subscription to the source store\n\t */\n\tsourceHandle?: Promise<{ unsubscribe: Function }>;\n}\n\nexport interface QueryTransformOptions<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> {\n\tqueriesAndTransformations: Array<Query<T> | TransformationDescriptor<T, any>>;\n\tsource: S;\n\tisTracking?: boolean;\n\ttrackingFetchDelay?: number;\n\tfetchAroundUpdates: boolean;\n}\n\nexport interface QueryTransformResult<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> {\n\tquery(query: Query<T>): this;\n\tfilter(filter: Filter<T>): this;\n\tfilter(test: (item: T) => boolean): this;\n\trange(range: StoreRange<T>): this;\n\trange(start: number, count: number): this;\n\tsort(sort: Sort<T> | ((a: T, b: T) => number) | string, descending?: boolean): this;\n\tobserve(): Observable<StoreDelta<T>>;\n\tobserve(id: string): Observable<T>;\n\tobserve(ids: string[]): Observable<ItemUpdate<T>>;\n\tget(ids: string | string[]): Promise<T[]>;\n\ttransform<V>(transformation: Patch<T, V> | ((item: T) => V)): QueryTransformResult<V, S>;\n\ttransform<V>(transformation: Patch<T, V> | ((item: T) => V), idTransform: string | ((item: V) => string)): MappedQueryTransformResult<V, S>;\n\tfetch(query?: Query<T>): FetchResult<T>;\n\tsource: S;\n}\n\nexport interface MappedQueryTransformResult<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> extends QueryTransformResult<T, S> {\n\t/**\n\t * Starts actively tracking this view, such that any time updates are made, this will fetch if necessary to make\n\t * sure it has the latest data.\n\t */\n\ttrack(): TrackedQueryTransformResult<T, S>;\n\tidentify(items: T[]): string[];\n\tidentify(item: T): string;\n\tidentify(items: T | T[]): string | string[];\n\tobserve(): Observable<TrackableStoreDelta<T>>;\n\t/**\n\t * These overrides aren't actually changing the signature, they are just necessary to make typescript happy about\n\t * the override of the no arg signature for observe\n\t */\n\tobserve(id: string): Observable<T>;\n\tobserve(ids: string[]): Observable<ItemUpdate<T>>;\n}\n\nexport interface TrackedQueryTransformResult<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> extends MappedQueryTransformResult<T, S> {\n\t/**\n\t * Create a new query transform result that is not tracking the source store but represents the same queries and\n\t * transforms\n\t */\n\trelease(): MappedQueryTransformResult<T, S>;\n}\n\n/**\n * Check if this is a 'mapped' query transform result\n * @param queryTransformResult\n * @returns {boolean}\n */\nfunction isMapped(\n\tqueryTransformResult: QueryTransformResult<any, any>\n): queryTransformResult is MappedQueryTransformResult<any, any> {\n\treturn typeof (<MappedQueryTransformResult<any, any>> queryTransformResult).track === 'function';\n}\n\n/**\n * Check if this is a patch or just a transform function\n * @param transform\n * @returns {boolean}\n */\nfunction isPatch<F, T>(transform: Patch<F, T> | ((item: F) => T)): transform is Patch<F, T> {\n\treturn typeof transform !== 'function';\n}\n\n/**\n * Checks if this is a query or a transformations descriptor\n * @param queryOrTransformation\n * @returns {boolean}\n */\nfunction isQuery<T, F>(queryOrTransformation: Query<T> | TransformationDescriptor<T, F>): queryOrTransformation is Query<T> {\n\tconst asTransformation = queryOrTransformation as TransformationDescriptor<T, F>;\n\tconst asQuery = queryOrTransformation as Query<T>;\n\treturn !asTransformation.transformation && !asTransformation.idTransform && typeof asQuery.apply === 'function';\n}\n\n/**\n * Checks if this is a query or a transformations descriptor\n * @param queryOrTransformation\n * @returns {boolean}\n */\nfunction isTransformation(queryOrTransformation: Query<any> | TransformationDescriptor<any, any>): queryOrTransformation is TransformationDescriptor<any, any> {\n\tconst asTransformation = queryOrTransformation as TransformationDescriptor<any, any>;\n\tconst asQuery = queryOrTransformation as Query<any>;\n\treturn asTransformation.transformation && typeof asQuery.apply !== 'function';\n}\n\n/**\n * Applies only the transformations in the queries and transformations array to the provided item(s). Useful for\n * converting an item from its original shape to the transformed shape when querying is not needed (e.g. for observing\n * individual items).\n * @param queriesAndTransformations\n * @param item An item or an array of items\n * @returns The transformed item or items\n */\nfunction transformData(\n\tqueriesAndTransformations: Array<Query<any> | TransformationDescriptor<any, any>>,\n\titem: any | any[]\n) {\n\tfunction transformSingleItem(item: any) {\n\t\treturn queriesAndTransformations\n\t\t\t.reduce((prev, next) => {\n\t\t\t\tif (isTransformation(next)) {\n\t\t\t\t\tconst transform = next.transformation;\n\t\t\t\t\treturn isPatch(transform) ? transform.apply(prev) : transform(prev);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn prev;\n\t\t\t\t}\n\t\t\t}, item);\n\t}\n\tif (Array.isArray(item)) {\n\t\treturn item.map(transformSingleItem);\n\t}\n\telse {\n\t\treturn transformSingleItem(item);\n\t}\n}\n\n/**\n * Pulls the item out of an `ItemUpdate` object and then delegates to `transformData` to transform it before creating\n * a new `ItemUpdate` with the modified data.\n * @param queriesAndTransformations\n * @param update\n * @returns A new `ItemUpdate` with any transformations applied\n */\nfunction transformItemUpdate<T, F>(\n\tqueriesAndTransformations: Array<Query<T> | TransformationDescriptor<T, F>>,\n\tupdate: ItemUpdate<T>\n) {\n\treturn {\n\t\tid: update.id,\n\t\titem: update.item ? transformData(queriesAndTransformations, update.item) : update.item\n\t};\n}\n\n/**\n * Compares the latest data to the previous local data to build the change records for a TrackedStoreDelta. Delegates\n * to `sendUpdate` to actually send the update to observers.\n * @param state\n * @param instance\n * @param newData\n * @param newIndex\n * @param update\n */\nfunction sendTrackedUpdate<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>>(\n\tstate: QueryTransformState<T, S>,\n\tinstance: MappedQueryTransformResult<T, S>,\n\tnewData: T[],\n\tnewIndex: Map<string, number>,\n\tupdate: StoreDelta<T>) {\n\tconst removedFromTracked: { item: T; id: string; previousIndex: number; }[] = [];\n\tconst addedToTracked: { item: T; id: string; index: number; }[] = [];\n\tconst movedInTracked: { item: T; id: string; previousIndex: number; index: number }[] = [];\n\n\tconst updateMap = instance.identify(update.updates).reduce((prev, next, index) => {\n\t\tprev.set(next, update.updates[index]);\n\t\treturn prev;\n\t}, new Map<string, T>());\n\t// Check updates for removals first as it will have the latest data for items moved out of\n\t// the tracked collection.\n\tupdateMap.forEach((item, id) => {\n\t\tif (!newIndex.has(id) && state.localIndex.has(id)) {\n\t\t\tremovedFromTracked.push({\n\t\t\t\titem: item,\n\t\t\t\tid: id,\n\t\t\t\tpreviousIndex: state.localIndex.get(id)!\n\t\t\t});\n\t\t}\n\t});\n\t// Handle removals and moves\n\tstate.localIndex.forEach((previousIndex, id) => {\n\t\tif (!newIndex.has(id) && !updateMap.has(id)) {\n\t\t\tremovedFromTracked.push({\n\t\t\t\titem: state.localData[previousIndex],\n\t\t\t\tid: id,\n\t\t\t\tpreviousIndex: previousIndex\n\t\t\t});\n\t\t}\n\t\telse if (state.localIndex.get(id) !== newIndex.get(id)) {\n\t\t\tconst index = newIndex.get(id)!;\n\t\t\tmovedInTracked.push({\n\t\t\t\titem: newData[index],\n\t\t\t\tid: id,\n\t\t\t\tindex: index,\n\t\t\t\tpreviousIndex: previousIndex\n\t\t\t});\n\t\t}\n\t});\n\n\t// Handle additions\n\tnewIndex.forEach((index, id) => {\n\t\tif (!state.localIndex.has(id)) {\n\t\t\taddedToTracked.push({\n\t\t\t\titem: newData[index],\n\t\t\t\tid: id,\n\t\t\t\tindex: index\n\t\t\t});\n\t\t}\n\t});\n\n\tconst trackedUpdate: TrackableStoreDelta<T> = {\n\t\tupdates: update.updates,\n\t\tadds: update.adds,\n\t\tdeletes: update.deletes,\n\t\tremovedFromTracked: removedFromTracked,\n\t\tmovedInTracked: movedInTracked,\n\t\taddedToTracked: addedToTracked,\n\t\tbeforeAll: update.beforeAll,\n\t\tafterAll: update.afterAll\n\t};\n\n\tsendUpdate(state, trackedUpdate);\n}\n\n/**\n * Sends the update if it actually represents any change in the data, and then removes observers that unsubscribed\n * from the list.\n * @param state\n * @param update\n */\nfunction sendUpdate<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>>(\n\tstate: QueryTransformState<T, S>,\n\tupdate: StoreDelta<T>\n) {\n\t// Don't send an update if nothing happened\n\tif (update.deletes.length || update.updates.length || update.adds.length || (\n\t\t\tisTracked(update) && (\n\t\t\t\tupdate.movedInTracked.length || update.addedToTracked.length || update.removedFromTracked.length\n\t\t\t)\n\t)) {\n\t\tstate.observers.forEach(function(observer) {\n\t\t\tif (isTracked(update)) {\n\t\t\t\tobserver.next({\n\t\t\t\t\tupdates: update.updates.slice(),\n\t\t\t\t\tadds: update.adds.slice(),\n\t\t\t\t\tdeletes: update.deletes.slice(),\n\t\t\t\t\tafterAll: update.afterAll.slice(),\n\t\t\t\t\tbeforeAll: update.beforeAll.slice(),\n\t\t\t\t\tmovedInTracked: update.movedInTracked.slice(),\n\t\t\t\t\tremovedFromTracked: update.removedFromTracked.slice(),\n\t\t\t\t\taddedToTracked: update.addedToTracked.slice()\n\t\t\t\t} as TrackableStoreDelta<T>);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobserver.next({\n\t\t\t\t\tupdates: update.updates.slice(),\n\t\t\t\t\tadds: update.adds.slice(),\n\t\t\t\t\tdeletes: update.deletes.slice(),\n\t\t\t\t\tafterAll: update.afterAll.slice(),\n\t\t\t\t\tbeforeAll: update.beforeAll.slice()\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * Applies all of the provided queries and transformations to the data, with some optional changes\n *  - If the instance and state are provided, then the localIndex will be checked and any items in it will be kept\n * \t  even if they would be otherwise eliminated by a filter. This is used specifically for updates, since if an item\n * \t  no longer satisifies the filters but is in the local index that means it has been modified and as a result removed\n * \t  from the tracked filter. We still want to have access to the new data for inclusion in the `removedFromTracked`\n * \t  update so that the user sees how the item changed to be removed from the collection.\n *  - If `ignoreSorts` is true, then sorts are not applied. This is useful for just filtering out data when it's not\n * \t  actually being used to represent the final, tracked, collection\n * \t- If `ignoreNonIncrementalQueries` is true, non-incremental queries like ranges are ignored. Similar to ignoreSorts,\n * \t  this is used when the data being transformed is not the full data set, since in that case non incremental queries\n * \t  are meaningless.\n *\n * @param queriesAndTransformations\n * @param data\n * @param instance\n * @param state\n * @param ignoreSorts\n * @param ignoreNonIncrementalQueries\n * @returns {any[]}\n */\nfunction queryAndTransformData<T>(\n\tqueriesAndTransformations: Array<Query<T> | TransformationDescriptor<T, T>>,\n\tdata: T[],\n\tinstance?: MappedQueryTransformResult<T, any>,\n\tstate?: QueryTransformState<T, any>,\n\tignoreSorts = false,\n\tignoreNonIncrementalQueries = false\n) {\n\treturn queriesAndTransformations.reduce((prev, next) => {\n\t\tif (isTransformation(next)) {\n\t\t\treturn transformData([ next ], prev);\n\t\t}\n\t\telse {\n\t\t\tif ((!ignoreSorts || next.queryType !== QueryType.Sort) && (!ignoreNonIncrementalQueries || next.incremental)) {\n\t\t\t\tif (instance && state && isFilter(next)) {\n\t\t\t\t\treturn next\n\t\t\t\t\t\t.or(createFilter().custom((item: T) => state.localIndex.has(instance.identify(item))))\n\t\t\t\t\t\t.apply(prev);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn next.apply(prev);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn prev;\n\t\t\t}\n\t\t}\n\t}, data);\n}\n\n/**\n * Removes items from adds and updates, and IDs from deletes, that don't belong in this query transform result. The\n * observers of this view don't want to see unrelated updates. currentUpdateIndex is used when operating on batch\n * updates. If updates are processed in a batch, an item might be added in one, and then removed in a later update. The\n * newly added item will not yet be represented in the local data because the update needs to be localized before it\n * can be used to update the local data. A single map can be passed as the currentUpdateIndex in multiple calls to\n * localizeUpdate, and can then serve as a signal that even though a deleted ID isn't in the local index it is still\n * a relevant update\n * @param state\n * @param update\n * @param instance\n * @param currentUpdateIndex\n * @returns {{deletes: string[], adds: any[], updates: any[], beforeAll: any[], afterAll: any[]}}\n */\nfunction localizeUpdate<T, S extends ObservableStore<T, any, any> & QueryTransformMixin<any, S>>(\n\tstate: QueryTransformState<T, S>,\n\tupdate: StoreDelta<T>,\n\tinstance?: MappedQueryTransformResult<T, any>,\n\tcurrentUpdateIndex?: Set<string>\n) {\n\n\t// Don't apply range queries, sorts, etc. to adds and updates, because those don't make sense in that context\n\tconst adds = queryAndTransformData(state.queriesAndTransformations, update.adds,  undefined, undefined, true, true);\n\tconst updates = queryAndTransformData(state.queriesAndTransformations, update.updates, instance, state, true, true);\n\tif (instance && currentUpdateIndex) {\n\t\tinstance.identify(adds.concat(updates)).map((id) => currentUpdateIndex.add(id));\n\t}\n\tconst deletes = update.deletes.filter((id) =>\n\t\tstate.localIndex.has(id) || currentUpdateIndex && currentUpdateIndex.has(id)\n\t);\n\t// Applying range queries to beforeAll and afterAll may not be completely accurate, in the case that\n\t// we are not eagerly fetching or tracking, but the data would definitely not be accurate if we don't apply them\n\t// and we shouldn't be returning more data than the queries require.\n\tconst beforeAll = queryAndTransformData(state.queriesAndTransformations, update.beforeAll);\n\tconst afterAll = queryAndTransformData(state.queriesAndTransformations, update.afterAll);\n\n\treturn {\n\t\tdeletes: deletes,\n\t\tadds: adds,\n\t\tupdates: updates,\n\t\tbeforeAll: beforeAll,\n\t\tafterAll: afterAll\n\t};\n}\n\nconst instanceStateMap = new WeakMap<QueryTransformResult<any, any>, QueryTransformState<any, any>>();\n\nexport interface QueryTransformResultFactory extends ComposeFactory<QueryTransformResult<any, any>, QueryTransformState<any, any>> {\n\t<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>>(options?: QueryTransformOptions<T, S>): QueryTransformResult<T, S>;\n}\n\nexport interface MappedQueryTransformResultFactory extends ComposeFactory<MappedQueryTransformResult<any, any>, QueryTransformState<any, any>> {\n\t<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>>(options?: QueryTransformOptions<T, S>): MappedQueryTransformResult<T, S>;\n}\n\nexport interface TrackedQueryTransformResultFactory extends ComposeFactory<TrackedQueryTransformResult<any, any>, QueryTransformState<any, any>> {\n\t<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>>(options?: QueryTransformOptions<T, S>): TrackedQueryTransformResult<T, S>;\n}\n\nexport const createQueryTransformResult: QueryTransformResultFactory = compose<QueryTransformResult<any, any>, any>({\n\tquery(this: QueryTransformResult<any, any>, query: Query<any>) {\n\t\tconst state = instanceStateMap.get(this);\n\t\tconst options: QueryTransformOptions<any, any> = {\n\t\t\tsource: state.source,\n\t\t\tqueriesAndTransformations: [ ...state.queriesAndTransformations, query ],\n\t\t\ttrackingFetchDelay: state.trackingFetchDelay,\n\t\t\tfetchAroundUpdates: state.fetchAroundUpdates\n\t\t};\n\t\tif (isMapped(this)) {\n\t\t\treturn createMappedQueryTransformResult(options);\n\t\t}\n\t\telse {\n\t\t\treturn createQueryTransformResult(options);\n\t\t}\n\t},\n\tfilter(this: QueryTransformResult<any, any>, filterOrTest: Filter<any> | ((item: any) => boolean)) {\n\t\tlet filter: Filter<any>;\n\t\tif (isFilter(filterOrTest)) {\n\t\t\tfilter = filterOrTest;\n\t\t}\n\t\telse {\n\t\t\tfilter = createFilter<any>().custom(<(item: any) => boolean> filterOrTest);\n\t\t}\n\n\t\treturn this.query(filter);\n\t},\n\n\trange(this: QueryTransformResult<any, any>, rangeOrStart: StoreRange<any> | number, count?: number) {\n\t\tlet range: StoreRange<any>;\n\t\tif (typeof count !== 'undefined') {\n\t\t\trange = createRange<any>(<number> rangeOrStart, count);\n\t\t}\n\t\telse {\n\t\t\trange = <StoreRange<any>> rangeOrStart;\n\t\t}\n\n\t\treturn this.query(range);\n\t},\n\n\tsort(this: QueryTransformResult<any, any>, sortOrComparator: Sort<any> | ((a: any, b: any) => number), descending?: boolean) {\n\t\tlet sort: Sort<any>;\n\t\tif (isSort(sortOrComparator)) {\n\t\t\tsort = sortOrComparator;\n\t\t}\n\t\telse {\n\t\t\tsort = createSort(sortOrComparator, descending);\n\t\t}\n\n\t\treturn this.query(sort);\n\t},\n\tobserve(this: QueryTransformResult<any, any>, idOrIds?: string | string[]) {\n\t\tconst state = instanceStateMap.get(this);\n\t\tif (!idOrIds) {\n\t\t\tif (!state.sourceHandle) {\n\t\t\t\tconst waitForFetchPromise: Promise<any> = state.initialFetch || Promise.resolve();\n\t\t\t\tstate.sourceHandle = waitForFetchPromise.then(() => {\n\t\t\t\t\treturn state.source.observe().subscribe((update: StoreDelta<any>) => {\n\t\t\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\t\t\tconst mapped = this;\n\t\t\t\t\t\tif (isMapped(mapped)) {\n\t\t\t\t\t\t\tif (state.fetchAroundUpdates || !state.isTracking) {\n\t\t\t\t\t\t\t\tupdate = localizeUpdate(state, update, mapped);\n\t\t\t\t\t\t\t\tconst newData = update.afterAll;\n\t\t\t\t\t\t\t\tconst newIndex = buildIndex(mapped.identify(newData));\n\t\t\t\t\t\t\t\tsendTrackedUpdate(state, mapped, newData, newIndex, update);\n\t\t\t\t\t\t\t\tstate.localData = newData;\n\t\t\t\t\t\t\t\tstate.localIndex = newIndex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Combine batched updates, use `currentUpdateIndex` to make sure deletes of items added and then deleted within\n\t\t\t\t\t\t\t\t// the span of the queued updates are not lost. These will be cancelled out by mergeDeltas, but both need\n\t\t\t\t\t\t\t\t// to be there to properly get cancelled out, otherwise the delete gets removed and the add survives, resulting\n\t\t\t\t\t\t\t\t// in an incorrect update\n\t\t\t\t\t\t\t\tupdate = localizeUpdate(state, update, mapped, state.currentUpdateIndex);\n\t\t\t\t\t\t\t\tstate.queuedUpdate = state.queuedUpdate ?\n\t\t\t\t\t\t\t\t\tmergeDeltas(mapped, state.queuedUpdate, update) : update;\n\t\t\t\t\t\t\t\t// Unfortunately if we have a non-incremental query and we are tracking, we will need to fetch\n\t\t\t\t\t\t\t\t// after each update. This is debounced to avoid rapidly issuing fetch requests in the case that a\n\t\t\t\t\t\t\t\t// series of updates are received in a short amount of time.\n\t\t\t\t\t\t\t\tstate.fetchAndSendUpdates(mapped);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tupdate = localizeUpdate(state, update);\n\t\t\t\t\t\t\tsendUpdate(state, update);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn state.observable;\n\t\t}\n\t\telse {\n\t\t\tif (Array.isArray(idOrIds)) {\n\t\t\t\treturn state.source\n\t\t\t\t\t.observe(idOrIds)\n\t\t\t\t\t.map((update: ItemUpdate<any>) => transformItemUpdate(state.queriesAndTransformations, update));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn state.source\n\t\t\t\t\t.observe(idOrIds)\n\t\t\t\t\t.map((update: any) => transformData(state.queriesAndTransformations, update));\n\t\t\t}\n\t\t}\n\t},\n\tget(this: QueryTransformResult<any, any>, ids: string | string[]) {\n\t\tconst state = instanceStateMap.get(this);\n\t\tconst promise: Promise<any> = state.initialFetch || Promise.resolve();\n\t\tconst mapped = isMapped(this);\n\t\treturn promise.then(() => {\n\t\t\tif (mapped) {\n\t\t\t\tif (Array.isArray(ids)) {\n\t\t\t\t\treturn ids.map((id) => state.localData[state.localIndex.get(id)!])\n\t\t\t\t\t\t.filter((item) => Boolean(item));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn state.localData[state.localIndex.get(ids)!];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.source.get(ids).then((data: {} | {}[]) => {\n\t\t\t\t\tif (Array.isArray(data)) {\n\t\t\t\t\t\treturn queryAndTransformData(state.queriesAndTransformations, data);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn queryAndTransformData(state.queriesAndTransformations, [ data ])[0];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t},\n\ttransform<V>(\n\t\tthis: QueryTransformResult<any, any>,\n\t\ttransformation: Patch<any, V> | ((item: any) => V),\n\t\tidTransform?: string | ((item: V) => string)\n\t): any {\n\t\tconst state = instanceStateMap.get(this);\n\t\tconst options: QueryTransformOptions<any, any> = {\n\t\t\tsource: state.source,\n\t\t\tqueriesAndTransformations: [\n\t\t\t\t...state.queriesAndTransformations,\n\t\t\t\t{ transformation: transformation, idTransform: idTransform }\n\t\t\t],\n\t\t\ttrackingFetchDelay: state.trackingFetchDelay,\n\t\t\tfetchAroundUpdates: state.fetchAroundUpdates\n\t\t};\n\t\tif (idTransform) {\n\t\t\treturn createMappedQueryTransformResult(options);\n\t\t}\n\t\telse {\n\t\t\treturn createQueryTransformResult(options);\n\t\t}\n\t},\n\tfetch(this: QueryTransformResult<any, any>, query?: Query<any>) {\n\t\tconst state = instanceStateMap.get(this);\n\n\t\tlet firstQuery = createCompoundQuery();\n\t\tconst queriesAndTransformations = state.queriesAndTransformations.slice();\n\t\tlet nextQuery = queriesAndTransformations.shift();\n\t\t// Get the queries that can be passed through to the store. This includes all queries up to and including the\n\t\t// first non incremental query(e.g. a range query) or up to and not including the first transformation\n\t\twhile (nextQuery && isQuery(nextQuery) && nextQuery.incremental) {\n\t\t\tfirstQuery = firstQuery.withQuery(nextQuery);\n\t\t\tnextQuery = queriesAndTransformations.shift();\n\t\t}\n\t\tif (nextQuery && isQuery(nextQuery)) {\n\t\t\tfirstQuery = firstQuery.withQuery(nextQuery);\n\t\t}\n\t\telse if (nextQuery) {\n\t\t\tqueriesAndTransformations.unshift(nextQuery);\n\t\t}\n\n\t\tconst mapped: MappedQueryTransformResult<any, any> | undefined = isMapped(this) ?\n\t\t\tthis as MappedQueryTransformResult<any, any> : undefined;\n\t\tlet nextUpdate: StoreDelta<any> = (state.queuedUpdate && mapped) ? state.queuedUpdate : {\n\t\t\tadds: [],\n\t\t\tupdates: [],\n\t\t\tdeletes: [],\n\t\t\tbeforeAll: [],\n\t\t\tafterAll: []\n\t\t};\n\t\tstate.currentUpdateIndex.clear();\n\t\tstate.queuedUpdate = undefined;\n\n\t\tlet resolveTotalLength: Function | undefined = undefined;\n\t\tlet rejectTotalLength: Function | undefined = undefined;\n\t\tconst totalLength = new Promise((resolve, reject) => {\n\t\t\tresolveTotalLength = resolve;\n\t\t\trejectTotalLength = reject;\n\t\t});\n\t\tlet resolveDataLength: Function;\n\t\tlet rejectDataLength: Function;\n\t\tconst dataLength = new Promise((resolve, reject) => {\n\t\t\tresolveDataLength = resolve;\n\t\t\trejectDataLength = reject;\n\t\t});\n\t\tconst fetchResult = state.source.fetch(firstQuery);\n\t\tconst resultsPromise = fetchResult.then(\n\t\t\t(newData: any[]) => {\n\t\t\t\t// We should apply the query transform result's own queries first so that the total size of the locally\n\t\t\t\t// cached data can be determined\n\t\t\t\tnewData = queryAndTransformData(queriesAndTransformations, newData);\n\t\t\t\tresolveDataLength(newData.length);\n\n\t\t\t\tif (mapped) {\n\t\t\t\t\tconst ids = mapped.identify(newData);\n\t\t\t\t\tconst newIndex = buildIndex(ids);\n\t\t\t\t\t// Update this way if this is not an initial fetch. If this is the initial fetch, then this\n\t\t\t\t\t// data (or subsequent data) will already be provided to observers in the initial notification, so don't\n\t\t\t\t\t// send a redundant one.\n\t\t\t\t\tif (resultsPromise !== state.initialFetch) {\n\t\t\t\t\t\tnextUpdate.beforeAll = state.localData;\n\t\t\t\t\t\tnextUpdate.afterAll = newData;\n\t\t\t\t\t\tsendTrackedUpdate(state, mapped, newData, newIndex, nextUpdate);\n\t\t\t\t\t}\n\t\t\t\t\tstate.localIndex = newIndex;\n\t\t\t\t\tstate.localData = newData;\n\t\t\t\t}\n\t\t\t\tif (query) {\n\t\t\t\t\tnewData = query.apply(newData);\n\t\t\t\t}\n\t\t\t\treturn newData;\n\t\t\t},\n\t\t\t(error: any) => {\n\t\t\t\trejectDataLength(error);\n\t\t\t\tthrow error;\n\t\t\t});\n\t\tfetchResult.totalLength.then(resolveTotalLength, rejectTotalLength);\n\t\tresultsPromise.dataLength = dataLength;\n\t\tresultsPromise.totalLength = totalLength;\n\n\t\tif (!state.initialFetch) {\n\t\t\tstate.initialFetch = resultsPromise;\n\t\t}\n\n\t\treturn resultsPromise;\n\t},\n\n\tget source(this: QueryTransformResult<any, any>) {\n\t\treturn instanceStateMap.get(this).source;\n\t}\n}, (instance: QueryTransformResult<any, any>, options?: QueryTransformOptions<any, any>) => {\n\tif (!options) {\n\t\tthrow Error('Query Transform result cannot be created without providing a source store');\n\t}\n\tconst observable = new Observable<StoreDelta<any>>((observer: Observer<StoreDelta<any>>) => {\n\t\tconst state = instanceStateMap.get(instance);\n\t\tstate.observers.push(observer);\n\t\tif (isMapped(instance)) {\n\t\t\tconst fetchPromise: Promise<any> = state.initialFetch || Promise.resolve();\n\t\t\tfetchPromise.then(() => {\n\t\t\t\tconst addedToTracked: { item: any; id: string; index: number; }[] = [];\n\t\t\t\tstate.localIndex.forEach((index, id) => {\n\t\t\t\t\taddedToTracked.push({\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\titem: state.localData[index],\n\t\t\t\t\t\tid: id\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tconst trackedDelta: TrackableStoreDelta<any> = {\n\t\t\t\t\tupdates: [],\n\t\t\t\t\tdeletes: [],\n\t\t\t\t\tadds: [],\n\t\t\t\t\taddedToTracked: addedToTracked.slice(),\n\t\t\t\t\tremovedFromTracked: [],\n\t\t\t\t\tmovedInTracked: [],\n\t\t\t\t\tafterAll: state.localData.slice(),\n\t\t\t\t\tbeforeAll: []\n\t\t\t\t};\n\t\t\t\tobserver.next(trackedDelta);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tobserver.next({\n\t\t\t\tupdates: [],\n\t\t\t\tadds: [],\n\t\t\t\tdeletes: [],\n\t\t\t\tbeforeAll: [],\n\t\t\t\tafterAll: state.localData.slice()\n\t\t\t});\n\t\t}\n\t\treturn () => {\n\t\t\tfunction remove(observer: Observer<StoreDelta<any>>) {\n\t\t\t\tstate.observers.splice(state.observers.indexOf(observer), 1);\n\t\t\t\tif (!state.observers.length && state.sourceHandle) {\n\t\t\t\t\tstate.sourceHandle.then((subscription) => {\n\t\t\t\t\t\tif (!state.observers.length) {\n\t\t\t\t\t\t\tsubscription.unsubscribe();\n\t\t\t\t\t\t\tstate.sourceHandle = undefined;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Do the actual removal on the next tick so that\n\t\t\t// we don't remove items from the array while we're iterating through it.\n\t\t\tsetTimeout(() => {\n\t\t\t\tremove(observer);\n\t\t\t});\n\t\t};\n\t});\n\n\tconst updateInPlace = canUpdateInPlace(options.queriesAndTransformations, instance);\n\n\tconst state: QueryTransformState<any, any> = {\n\t\tsource: options.source,\n\t\tobservers: [],\n\t\tcanUpdateInPlace: updateInPlace,\n\t\tobservable: observable,\n\t\tlocalData: [],\n\t\tlocalIndex: new Map<string, number>(),\n\t\tqueriesAndTransformations: options.queriesAndTransformations,\n\t\tisTracking: options.isTracking,\n\t\ttrackingFetchDelay: options.trackingFetchDelay,\n\t\tcurrentUpdateIndex: new Set<string>(),\n\t\tfetchAndSendUpdates: debounce((instance: QueryTransformResult<any, any>) => {\n\t\t\tinstance.fetch();\n\t\t}, options.trackingFetchDelay || 20),\n\t\tfetchAroundUpdates: options.fetchAroundUpdates\n\t};\n\tinstanceStateMap.set(instance, state);\n\n\tif (options.isTracking && !options.fetchAroundUpdates) {\n\t\tinstance.fetch();\n\t}\n\n});\n\n// TODO - Figure out how to get these factory types to work\nconst createMappedQueryTransformResult: MappedQueryTransformResultFactory = <any> createQueryTransformResult\n\t.mixin({\n\t\tmixin: compose({\n\t\t\ttrack(this: MappedQueryTransformResult<any, any>): TrackedQueryTransformResult<any, any> {\n\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\treturn createTrackedQueryTransformResult({\n\t\t\t\t\tisTracking: true,\n\t\t\t\t\tsource: state.source,\n\t\t\t\t\ttrackingFetchDelay: state.trackingFetchDelay,\n\t\t\t\t\tqueriesAndTransformations: state.queriesAndTransformations,\n\t\t\t\t\tfetchAroundUpdates: state.fetchAroundUpdates\n\t\t\t\t});\n\t\t\t},\n\t\t\tidentify(this: QueryTransformResult<any, any>, items: any[] | any): string | string[] {\n\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\tconst lastTransformation = state.queriesAndTransformations.reduce<TransformationDescriptor<any, any> | undefined>(\n\t\t\t\t\t(prev, next) => isTransformation(next) ? next : prev, undefined\n\t\t\t\t);\n\t\t\t\tconst itemArray = Array.isArray(items) ? items : [ items ];\n\t\t\t\tif (lastTransformation) {\n\t\t\t\t\tconst idTransform = lastTransformation.idTransform!;\n\t\t\t\t\tif (typeof idTransform === 'string') {\n\t\t\t\t\t\treturn itemArray.map((item) => item[idTransform]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn itemArray.map(idTransform);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn state.source.identify(items);\n\t\t\t}\n\t\t})\n\t});\n\nexport const createTrackedQueryTransformResult: TrackedQueryTransformResultFactory = <any> createMappedQueryTransformResult\n\t.mixin({\n\t\tmixin: compose({\n\t\t\trelease(this: QueryTransformResult<any, any>) {\n\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\treturn createMappedQueryTransformResult({\n\t\t\t\t\tisTracking: false,\n\t\t\t\t\tsource: state.source,\n\t\t\t\t\tqueriesAndTransformations: state.queriesAndTransformations,\n\t\t\t\t\tfetchAroundUpdates: state.fetchAroundUpdates\n\t\t\t\t});\n\t\t\t}\n\t\t})\n\t});\n\nexport default createMappedQueryTransformResult;\n"]}