import { ObservableStore, ItemUpdate, StoreDelta } from './mixins/createObservableStoreMixin';
import { Query } from '../query/interfaces';
import { Observable, Observer } from '@dojo/core/Observable';
import { Patch } from '../patch/createPatch';
import { ComposeFactory } from '@dojo/compose/compose';
import { Filter } from '../query/createFilter';
import { StoreRange } from '../query/createStoreRange';
import { Sort } from '../query/createSort';
import Promise from '@dojo/shim/Promise';
import Map from '@dojo/shim/Map';
import Set from '@dojo/shim/Set';
import { QueryTransformMixin } from './mixins/createQueryTransformMixin';
import { FetchResult } from '../storage/createInMemoryStorage';
export interface TrackableStoreDelta<T> extends StoreDelta<T> {
    /**
     * Contains info for any items that were formerly in the tracked collection and are now not, regardless of how
     * those items were removed
     */
    removedFromTracked: {
        item: T;
        id: string;
        previousIndex: number;
    }[];
    /**
     * Contains info for any items that are now in the tracked collection and formerly were not, regardless of how
     * those items were added
     */
    addedToTracked: {
        item: T;
        id: string;
        index: number;
    }[];
    /**
     * Contains info were previously and still are in the tracked collection but have changed position, regardless of
     * how the items were moved.
     */
    movedInTracked: {
        item: T;
        id: string;
        previousIndex: number;
        index: number;
    }[];
}
/**
 * Describes a transformation
 */
export declare type TransformationDescriptor<T, F> = {
    transformation: Patch<F, T> | ((item: F) => T);
    idTransform?: string | ((item: T) => string);
};
export interface QueryTransformState<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> {
    /**
     * Queries and transformations for this query transform result
     */
    queriesAndTransformations: Array<Query<any> | TransformationDescriptor<any, any>>;
    /**
     * Tracks whether we can modify the local collection in place or need to fetch to get the correct state after an
     * update
     */
    canUpdateInPlace: boolean;
    /**
     * Tracks whether we're tracking this collection
     */
    isTracking?: boolean;
    /**
     * Optional value that indicates the amount of time to debounce the fetch called after receiving an update.
     */
    trackingFetchDelay?: number;
    /**
     * A debounced function that just delegates to the instance's fetch method
     * @param instance
     */
    fetchAndSendUpdates: (instance: QueryTransformResult<T, S>) => void;
    /**
     * The store this query transform result comes from
     */
    source: S;
    /**
     * The observable that observers of this query transform result will be provided
     */
    observable: Observable<StoreDelta<T>>;
    /**
     * Observers of this query transform result
     */
    observers: Observer<StoreDelta<T>>[];
    /**
     * The local copy of the data for this view
     */
    localData: T[];
    /**
     * Updates ready to be send after the next fetch
     */
    queuedUpdate?: StoreDelta<T>;
    /**
     * Keeps track of new item IDs as updates are being queued
     */
    currentUpdateIndex: Set<string>;
    /**
     * Promise tracking the initial fetch if we are tracking and are not fetchingAroundUpdates
     */
    initialFetch?: Promise<T[]>;
    /**
     * Is the parent store fetching around updates
     * If the parent store is fetching around updates, we will always have the latest superset of this view's data in
     * the updates it receives locally. In that case, even if actively tracking, no additional fetches need to be
     * performed, the local queries and transformations can just be applied to the new data directly.
     */
    fetchAroundUpdates: boolean;
    /**
     * Maps IDs to indices in localDAta
     */
    localIndex: Map<string, number>;
    /**
     * Handle to the subscription to the source store
     */
    sourceHandle?: Promise<{
        unsubscribe: Function;
    }>;
}
export interface QueryTransformOptions<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> {
    queriesAndTransformations: Array<Query<T> | TransformationDescriptor<T, any>>;
    source: S;
    isTracking?: boolean;
    trackingFetchDelay?: number;
    fetchAroundUpdates: boolean;
}
export interface QueryTransformResult<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> {
    query(query: Query<T>): this;
    filter(filter: Filter<T>): this;
    filter(test: (item: T) => boolean): this;
    range(range: StoreRange<T>): this;
    range(start: number, count: number): this;
    sort(sort: Sort<T> | ((a: T, b: T) => number) | string, descending?: boolean): this;
    observe(): Observable<StoreDelta<T>>;
    observe(id: string): Observable<T>;
    observe(ids: string[]): Observable<ItemUpdate<T>>;
    get(ids: string | string[]): Promise<T[]>;
    transform<V>(transformation: Patch<T, V> | ((item: T) => V)): QueryTransformResult<V, S>;
    transform<V>(transformation: Patch<T, V> | ((item: T) => V), idTransform: string | ((item: V) => string)): MappedQueryTransformResult<V, S>;
    fetch(query?: Query<T>): FetchResult<T>;
    source: S;
}
export interface MappedQueryTransformResult<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> extends QueryTransformResult<T, S> {
    /**
     * Starts actively tracking this view, such that any time updates are made, this will fetch if necessary to make
     * sure it has the latest data.
     */
    track(): TrackedQueryTransformResult<T, S>;
    identify(items: T[]): string[];
    identify(item: T): string;
    identify(items: T | T[]): string | string[];
    observe(): Observable<TrackableStoreDelta<T>>;
    /**
     * These overrides aren't actually changing the signature, they are just necessary to make typescript happy about
     * the override of the no arg signature for observe
     */
    observe(id: string): Observable<T>;
    observe(ids: string[]): Observable<ItemUpdate<T>>;
}
export interface TrackedQueryTransformResult<T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>> extends MappedQueryTransformResult<T, S> {
    /**
     * Create a new query transform result that is not tracking the source store but represents the same queries and
     * transforms
     */
    release(): MappedQueryTransformResult<T, S>;
}
export interface QueryTransformResultFactory extends ComposeFactory<QueryTransformResult<any, any>, QueryTransformState<any, any>> {
    <T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>>(options?: QueryTransformOptions<T, S>): QueryTransformResult<T, S>;
}
export interface MappedQueryTransformResultFactory extends ComposeFactory<MappedQueryTransformResult<any, any>, QueryTransformState<any, any>> {
    <T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>>(options?: QueryTransformOptions<T, S>): MappedQueryTransformResult<T, S>;
}
export interface TrackedQueryTransformResultFactory extends ComposeFactory<TrackedQueryTransformResult<any, any>, QueryTransformState<any, any>> {
    <T, S extends ObservableStore<any, any, any> & QueryTransformMixin<any, S>>(options?: QueryTransformOptions<T, S>): TrackedQueryTransformResult<T, S>;
}
export declare const createQueryTransformResult: QueryTransformResultFactory;
declare const createMappedQueryTransformResult: MappedQueryTransformResultFactory;
export declare const createTrackedQueryTransformResult: TrackedQueryTransformResultFactory;
export default createMappedQueryTransformResult;
