(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./mixins/createObservableStoreMixin", "@dojo/core/Observable", "@dojo/compose/compose", "../query/createFilter", "../query/createStoreRange", "../query/createSort", "../query/createCompoundQuery", "@dojo/shim/Promise", "@dojo/shim/Map", "@dojo/shim/Set", "@dojo/shim/WeakMap", "@dojo/core/util", "./mixins/createQueryTransformMixin"], factory);
    }
})(function (require, exports) {
    "use strict";
    var createObservableStoreMixin_1 = require("./mixins/createObservableStoreMixin");
    var Observable_1 = require("@dojo/core/Observable");
    var compose_1 = require("@dojo/compose/compose");
    var createFilter_1 = require("../query/createFilter");
    var createStoreRange_1 = require("../query/createStoreRange");
    var createSort_1 = require("../query/createSort");
    var createCompoundQuery_1 = require("../query/createCompoundQuery");
    var Promise_1 = require("@dojo/shim/Promise");
    var Map_1 = require("@dojo/shim/Map");
    var Set_1 = require("@dojo/shim/Set");
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var util_1 = require("@dojo/core/util");
    var createQueryTransformMixin_1 = require("./mixins/createQueryTransformMixin");
    /**
     * Checks if this is a tracked update or not
     * @param storeDelta
     * @returns {Boolean}
     */
    function isTracked(storeDelta) {
        var tracked = storeDelta;
        return Boolean(tracked.removedFromTracked || tracked.addedToTracked || tracked.movedInTracked);
    }
    /**
     * If this function is 'mapped'(Items can be identified), and it contains only transformations and incremental queries,
     * then we can update it in place, assuming that we are notified about all changes and are starting from the correct
     * data.
     * @param queriesAndTransforms
     * @param result
     * @returns {boolean|boolean}
     */
    function canUpdateInPlace(queriesAndTransforms, result) {
        return isMapped(result) && queriesAndTransforms.every(function (queryOrTransformation) {
            return !isQuery(queryOrTransformation) || Boolean(queryOrTransformation.incremental);
        });
    }
    /**
     * Check if this is a 'mapped' query transform result
     * @param queryTransformResult
     * @returns {boolean}
     */
    function isMapped(queryTransformResult) {
        return typeof queryTransformResult.track === 'function';
    }
    /**
     * Check if this is a patch or just a transform function
     * @param transform
     * @returns {boolean}
     */
    function isPatch(transform) {
        return typeof transform !== 'function';
    }
    /**
     * Checks if this is a query or a transformations descriptor
     * @param queryOrTransformation
     * @returns {boolean}
     */
    function isQuery(queryOrTransformation) {
        var asTransformation = queryOrTransformation;
        var asQuery = queryOrTransformation;
        return !asTransformation.transformation && !asTransformation.idTransform && typeof asQuery.apply === 'function';
    }
    /**
     * Checks if this is a query or a transformations descriptor
     * @param queryOrTransformation
     * @returns {boolean}
     */
    function isTransformation(queryOrTransformation) {
        var asTransformation = queryOrTransformation;
        var asQuery = queryOrTransformation;
        return asTransformation.transformation && typeof asQuery.apply !== 'function';
    }
    /**
     * Applies only the transformations in the queries and transformations array to the provided item(s). Useful for
     * converting an item from its original shape to the transformed shape when querying is not needed (e.g. for observing
     * individual items).
     * @param queriesAndTransformations
     * @param item An item or an array of items
     * @returns The transformed item or items
     */
    function transformData(queriesAndTransformations, item) {
        function transformSingleItem(item) {
            return queriesAndTransformations
                .reduce(function (prev, next) {
                if (isTransformation(next)) {
                    var transform = next.transformation;
                    return isPatch(transform) ? transform.apply(prev) : transform(prev);
                }
                else {
                    return prev;
                }
            }, item);
        }
        if (Array.isArray(item)) {
            return item.map(transformSingleItem);
        }
        else {
            return transformSingleItem(item);
        }
    }
    /**
     * Pulls the item out of an `ItemUpdate` object and then delegates to `transformData` to transform it before creating
     * a new `ItemUpdate` with the modified data.
     * @param queriesAndTransformations
     * @param update
     * @returns A new `ItemUpdate` with any transformations applied
     */
    function transformItemUpdate(queriesAndTransformations, update) {
        return {
            id: update.id,
            item: update.item ? transformData(queriesAndTransformations, update.item) : update.item
        };
    }
    /**
     * Compares the latest data to the previous local data to build the change records for a TrackedStoreDelta. Delegates
     * to `sendUpdate` to actually send the update to observers.
     * @param state
     * @param instance
     * @param newData
     * @param newIndex
     * @param update
     */
    function sendTrackedUpdate(state, instance, newData, newIndex, update) {
        var removedFromTracked = [];
        var addedToTracked = [];
        var movedInTracked = [];
        var updateMap = instance.identify(update.updates).reduce(function (prev, next, index) {
            prev.set(next, update.updates[index]);
            return prev;
        }, new Map_1.default());
        // Check updates for removals first as it will have the latest data for items moved out of
        // the tracked collection.
        updateMap.forEach(function (item, id) {
            if (!newIndex.has(id) && state.localIndex.has(id)) {
                removedFromTracked.push({
                    item: item,
                    id: id,
                    previousIndex: state.localIndex.get(id)
                });
            }
        });
        // Handle removals and moves
        state.localIndex.forEach(function (previousIndex, id) {
            if (!newIndex.has(id) && !updateMap.has(id)) {
                removedFromTracked.push({
                    item: state.localData[previousIndex],
                    id: id,
                    previousIndex: previousIndex
                });
            }
            else if (state.localIndex.get(id) !== newIndex.get(id)) {
                var index = newIndex.get(id);
                movedInTracked.push({
                    item: newData[index],
                    id: id,
                    index: index,
                    previousIndex: previousIndex
                });
            }
        });
        // Handle additions
        newIndex.forEach(function (index, id) {
            if (!state.localIndex.has(id)) {
                addedToTracked.push({
                    item: newData[index],
                    id: id,
                    index: index
                });
            }
        });
        var trackedUpdate = {
            updates: update.updates,
            adds: update.adds,
            deletes: update.deletes,
            removedFromTracked: removedFromTracked,
            movedInTracked: movedInTracked,
            addedToTracked: addedToTracked,
            beforeAll: update.beforeAll,
            afterAll: update.afterAll
        };
        sendUpdate(state, trackedUpdate);
    }
    /**
     * Sends the update if it actually represents any change in the data, and then removes observers that unsubscribed
     * from the list.
     * @param state
     * @param update
     */
    function sendUpdate(state, update) {
        // Don't send an update if nothing happened
        if (update.deletes.length || update.updates.length || update.adds.length || (isTracked(update) && (update.movedInTracked.length || update.addedToTracked.length || update.removedFromTracked.length))) {
            state.observers.forEach(function (observer) {
                if (isTracked(update)) {
                    observer.next({
                        updates: update.updates.slice(),
                        adds: update.adds.slice(),
                        deletes: update.deletes.slice(),
                        afterAll: update.afterAll.slice(),
                        beforeAll: update.beforeAll.slice(),
                        movedInTracked: update.movedInTracked.slice(),
                        removedFromTracked: update.removedFromTracked.slice(),
                        addedToTracked: update.addedToTracked.slice()
                    });
                }
                else {
                    observer.next({
                        updates: update.updates.slice(),
                        adds: update.adds.slice(),
                        deletes: update.deletes.slice(),
                        afterAll: update.afterAll.slice(),
                        beforeAll: update.beforeAll.slice()
                    });
                }
            });
        }
    }
    /**
     * Applies all of the provided queries and transformations to the data, with some optional changes
     *  - If the instance and state are provided, then the localIndex will be checked and any items in it will be kept
     * 	  even if they would be otherwise eliminated by a filter. This is used specifically for updates, since if an item
     * 	  no longer satisifies the filters but is in the local index that means it has been modified and as a result removed
     * 	  from the tracked filter. We still want to have access to the new data for inclusion in the `removedFromTracked`
     * 	  update so that the user sees how the item changed to be removed from the collection.
     *  - If `ignoreSorts` is true, then sorts are not applied. This is useful for just filtering out data when it's not
     * 	  actually being used to represent the final, tracked, collection
     * 	- If `ignoreNonIncrementalQueries` is true, non-incremental queries like ranges are ignored. Similar to ignoreSorts,
     * 	  this is used when the data being transformed is not the full data set, since in that case non incremental queries
     * 	  are meaningless.
     *
     * @param queriesAndTransformations
     * @param data
     * @param instance
     * @param state
     * @param ignoreSorts
     * @param ignoreNonIncrementalQueries
     * @returns {any[]}
     */
    function queryAndTransformData(queriesAndTransformations, data, instance, state, ignoreSorts, ignoreNonIncrementalQueries) {
        if (ignoreSorts === void 0) { ignoreSorts = false; }
        if (ignoreNonIncrementalQueries === void 0) { ignoreNonIncrementalQueries = false; }
        return queriesAndTransformations.reduce(function (prev, next) {
            if (isTransformation(next)) {
                return transformData([next], prev);
            }
            else {
                if ((!ignoreSorts || next.queryType !== 1 /* Sort */) && (!ignoreNonIncrementalQueries || next.incremental)) {
                    if (instance && state && createQueryTransformMixin_1.isFilter(next)) {
                        return next
                            .or(createFilter_1.default().custom(function (item) { return state.localIndex.has(instance.identify(item)); }))
                            .apply(prev);
                    }
                    else {
                        return next.apply(prev);
                    }
                }
                else {
                    return prev;
                }
            }
        }, data);
    }
    /**
     * Removes items from adds and updates, and IDs from deletes, that don't belong in this query transform result. The
     * observers of this view don't want to see unrelated updates. currentUpdateIndex is used when operating on batch
     * updates. If updates are processed in a batch, an item might be added in one, and then removed in a later update. The
     * newly added item will not yet be represented in the local data because the update needs to be localized before it
     * can be used to update the local data. A single map can be passed as the currentUpdateIndex in multiple calls to
     * localizeUpdate, and can then serve as a signal that even though a deleted ID isn't in the local index it is still
     * a relevant update
     * @param state
     * @param update
     * @param instance
     * @param currentUpdateIndex
     * @returns {{deletes: string[], adds: any[], updates: any[], beforeAll: any[], afterAll: any[]}}
     */
    function localizeUpdate(state, update, instance, currentUpdateIndex) {
        // Don't apply range queries, sorts, etc. to adds and updates, because those don't make sense in that context
        var adds = queryAndTransformData(state.queriesAndTransformations, update.adds, undefined, undefined, true, true);
        var updates = queryAndTransformData(state.queriesAndTransformations, update.updates, instance, state, true, true);
        if (instance && currentUpdateIndex) {
            instance.identify(adds.concat(updates)).map(function (id) { return currentUpdateIndex.add(id); });
        }
        var deletes = update.deletes.filter(function (id) {
            return state.localIndex.has(id) || currentUpdateIndex && currentUpdateIndex.has(id);
        });
        // Applying range queries to beforeAll and afterAll may not be completely accurate, in the case that
        // we are not eagerly fetching or tracking, but the data would definitely not be accurate if we don't apply them
        // and we shouldn't be returning more data than the queries require.
        var beforeAll = queryAndTransformData(state.queriesAndTransformations, update.beforeAll);
        var afterAll = queryAndTransformData(state.queriesAndTransformations, update.afterAll);
        return {
            deletes: deletes,
            adds: adds,
            updates: updates,
            beforeAll: beforeAll,
            afterAll: afterAll
        };
    }
    var instanceStateMap = new WeakMap_1.default();
    exports.createQueryTransformResult = compose_1.default({
        query: function (query) {
            var state = instanceStateMap.get(this);
            var options = {
                source: state.source,
                queriesAndTransformations: state.queriesAndTransformations.concat([query]),
                trackingFetchDelay: state.trackingFetchDelay,
                fetchAroundUpdates: state.fetchAroundUpdates
            };
            if (isMapped(this)) {
                return createMappedQueryTransformResult(options);
            }
            else {
                return exports.createQueryTransformResult(options);
            }
        },
        filter: function (filterOrTest) {
            var filter;
            if (createQueryTransformMixin_1.isFilter(filterOrTest)) {
                filter = filterOrTest;
            }
            else {
                filter = createFilter_1.default().custom(filterOrTest);
            }
            return this.query(filter);
        },
        range: function (rangeOrStart, count) {
            var range;
            if (typeof count !== 'undefined') {
                range = createStoreRange_1.default(rangeOrStart, count);
            }
            else {
                range = rangeOrStart;
            }
            return this.query(range);
        },
        sort: function (sortOrComparator, descending) {
            var sort;
            if (createQueryTransformMixin_1.isSort(sortOrComparator)) {
                sort = sortOrComparator;
            }
            else {
                sort = createSort_1.default(sortOrComparator, descending);
            }
            return this.query(sort);
        },
        observe: function (idOrIds) {
            var _this = this;
            var state = instanceStateMap.get(this);
            if (!idOrIds) {
                if (!state.sourceHandle) {
                    var waitForFetchPromise = state.initialFetch || Promise_1.default.resolve();
                    state.sourceHandle = waitForFetchPromise.then(function () {
                        return state.source.observe().subscribe(function (update) {
                            var state = instanceStateMap.get(_this);
                            var mapped = _this;
                            if (isMapped(mapped)) {
                                if (state.fetchAroundUpdates || !state.isTracking) {
                                    update = localizeUpdate(state, update, mapped);
                                    var newData = update.afterAll;
                                    var newIndex = createObservableStoreMixin_1.buildIndex(mapped.identify(newData));
                                    sendTrackedUpdate(state, mapped, newData, newIndex, update);
                                    state.localData = newData;
                                    state.localIndex = newIndex;
                                }
                                else {
                                    // Combine batched updates, use `currentUpdateIndex` to make sure deletes of items added and then deleted within
                                    // the span of the queued updates are not lost. These will be cancelled out by mergeDeltas, but both need
                                    // to be there to properly get cancelled out, otherwise the delete gets removed and the add survives, resulting
                                    // in an incorrect update
                                    update = localizeUpdate(state, update, mapped, state.currentUpdateIndex);
                                    state.queuedUpdate = state.queuedUpdate ?
                                        createObservableStoreMixin_1.mergeDeltas(mapped, state.queuedUpdate, update) : update;
                                    // Unfortunately if we have a non-incremental query and we are tracking, we will need to fetch
                                    // after each update. This is debounced to avoid rapidly issuing fetch requests in the case that a
                                    // series of updates are received in a short amount of time.
                                    state.fetchAndSendUpdates(mapped);
                                }
                            }
                            else {
                                update = localizeUpdate(state, update);
                                sendUpdate(state, update);
                            }
                        });
                    });
                }
                return state.observable;
            }
            else {
                if (Array.isArray(idOrIds)) {
                    return state.source
                        .observe(idOrIds)
                        .map(function (update) { return transformItemUpdate(state.queriesAndTransformations, update); });
                }
                else {
                    return state.source
                        .observe(idOrIds)
                        .map(function (update) { return transformData(state.queriesAndTransformations, update); });
                }
            }
        },
        get: function (ids) {
            var _this = this;
            var state = instanceStateMap.get(this);
            var promise = state.initialFetch || Promise_1.default.resolve();
            var mapped = isMapped(this);
            return promise.then(function () {
                if (mapped) {
                    if (Array.isArray(ids)) {
                        return ids.map(function (id) { return state.localData[state.localIndex.get(id)]; })
                            .filter(function (item) { return Boolean(item); });
                    }
                    else {
                        return state.localData[state.localIndex.get(ids)];
                    }
                }
                else {
                    return _this.source.get(ids).then(function (data) {
                        if (Array.isArray(data)) {
                            return queryAndTransformData(state.queriesAndTransformations, data);
                        }
                        else {
                            return queryAndTransformData(state.queriesAndTransformations, [data])[0];
                        }
                    });
                }
            });
        },
        transform: function (transformation, idTransform) {
            var state = instanceStateMap.get(this);
            var options = {
                source: state.source,
                queriesAndTransformations: state.queriesAndTransformations.concat([
                    { transformation: transformation, idTransform: idTransform }
                ]),
                trackingFetchDelay: state.trackingFetchDelay,
                fetchAroundUpdates: state.fetchAroundUpdates
            };
            if (idTransform) {
                return createMappedQueryTransformResult(options);
            }
            else {
                return exports.createQueryTransformResult(options);
            }
        },
        fetch: function (query) {
            var state = instanceStateMap.get(this);
            var firstQuery = createCompoundQuery_1.default();
            var queriesAndTransformations = state.queriesAndTransformations.slice();
            var nextQuery = queriesAndTransformations.shift();
            // Get the queries that can be passed through to the store. This includes all queries up to and including the
            // first non incremental query(e.g. a range query) or up to and not including the first transformation
            while (nextQuery && isQuery(nextQuery) && nextQuery.incremental) {
                firstQuery = firstQuery.withQuery(nextQuery);
                nextQuery = queriesAndTransformations.shift();
            }
            if (nextQuery && isQuery(nextQuery)) {
                firstQuery = firstQuery.withQuery(nextQuery);
            }
            else if (nextQuery) {
                queriesAndTransformations.unshift(nextQuery);
            }
            var mapped = isMapped(this) ?
                this : undefined;
            var nextUpdate = (state.queuedUpdate && mapped) ? state.queuedUpdate : {
                adds: [],
                updates: [],
                deletes: [],
                beforeAll: [],
                afterAll: []
            };
            state.currentUpdateIndex.clear();
            state.queuedUpdate = undefined;
            var resolveTotalLength = undefined;
            var rejectTotalLength = undefined;
            var totalLength = new Promise_1.default(function (resolve, reject) {
                resolveTotalLength = resolve;
                rejectTotalLength = reject;
            });
            var resolveDataLength;
            var rejectDataLength;
            var dataLength = new Promise_1.default(function (resolve, reject) {
                resolveDataLength = resolve;
                rejectDataLength = reject;
            });
            var fetchResult = state.source.fetch(firstQuery);
            var resultsPromise = fetchResult.then(function (newData) {
                // We should apply the query transform result's own queries first so that the total size of the locally
                // cached data can be determined
                newData = queryAndTransformData(queriesAndTransformations, newData);
                resolveDataLength(newData.length);
                if (mapped) {
                    var ids = mapped.identify(newData);
                    var newIndex = createObservableStoreMixin_1.buildIndex(ids);
                    // Update this way if this is not an initial fetch. If this is the initial fetch, then this
                    // data (or subsequent data) will already be provided to observers in the initial notification, so don't
                    // send a redundant one.
                    if (resultsPromise !== state.initialFetch) {
                        nextUpdate.beforeAll = state.localData;
                        nextUpdate.afterAll = newData;
                        sendTrackedUpdate(state, mapped, newData, newIndex, nextUpdate);
                    }
                    state.localIndex = newIndex;
                    state.localData = newData;
                }
                if (query) {
                    newData = query.apply(newData);
                }
                return newData;
            }, function (error) {
                rejectDataLength(error);
                throw error;
            });
            fetchResult.totalLength.then(resolveTotalLength, rejectTotalLength);
            resultsPromise.dataLength = dataLength;
            resultsPromise.totalLength = totalLength;
            if (!state.initialFetch) {
                state.initialFetch = resultsPromise;
            }
            return resultsPromise;
        },
        get source() {
            return instanceStateMap.get(this).source;
        }
    }, function (instance, options) {
        if (!options) {
            throw Error('Query Transform result cannot be created without providing a source store');
        }
        var observable = new Observable_1.Observable(function (observer) {
            var state = instanceStateMap.get(instance);
            state.observers.push(observer);
            if (isMapped(instance)) {
                var fetchPromise = state.initialFetch || Promise_1.default.resolve();
                fetchPromise.then(function () {
                    var addedToTracked = [];
                    state.localIndex.forEach(function (index, id) {
                        addedToTracked.push({
                            index: index,
                            item: state.localData[index],
                            id: id
                        });
                    });
                    var trackedDelta = {
                        updates: [],
                        deletes: [],
                        adds: [],
                        addedToTracked: addedToTracked.slice(),
                        removedFromTracked: [],
                        movedInTracked: [],
                        afterAll: state.localData.slice(),
                        beforeAll: []
                    };
                    observer.next(trackedDelta);
                });
            }
            else {
                observer.next({
                    updates: [],
                    adds: [],
                    deletes: [],
                    beforeAll: [],
                    afterAll: state.localData.slice()
                });
            }
            return function () {
                function remove(observer) {
                    state.observers.splice(state.observers.indexOf(observer), 1);
                    if (!state.observers.length && state.sourceHandle) {
                        state.sourceHandle.then(function (subscription) {
                            if (!state.observers.length) {
                                subscription.unsubscribe();
                                state.sourceHandle = undefined;
                            }
                        });
                    }
                }
                // Do the actual removal on the next tick so that
                // we don't remove items from the array while we're iterating through it.
                setTimeout(function () {
                    remove(observer);
                });
            };
        });
        var updateInPlace = canUpdateInPlace(options.queriesAndTransformations, instance);
        var state = {
            source: options.source,
            observers: [],
            canUpdateInPlace: updateInPlace,
            observable: observable,
            localData: [],
            localIndex: new Map_1.default(),
            queriesAndTransformations: options.queriesAndTransformations,
            isTracking: options.isTracking,
            trackingFetchDelay: options.trackingFetchDelay,
            currentUpdateIndex: new Set_1.default(),
            fetchAndSendUpdates: util_1.debounce(function (instance) {
                instance.fetch();
            }, options.trackingFetchDelay || 20),
            fetchAroundUpdates: options.fetchAroundUpdates
        };
        instanceStateMap.set(instance, state);
        if (options.isTracking && !options.fetchAroundUpdates) {
            instance.fetch();
        }
    });
    // TODO - Figure out how to get these factory types to work
    var createMappedQueryTransformResult = exports.createQueryTransformResult
        .mixin({
        mixin: compose_1.default({
            track: function () {
                var state = instanceStateMap.get(this);
                return exports.createTrackedQueryTransformResult({
                    isTracking: true,
                    source: state.source,
                    trackingFetchDelay: state.trackingFetchDelay,
                    queriesAndTransformations: state.queriesAndTransformations,
                    fetchAroundUpdates: state.fetchAroundUpdates
                });
            },
            identify: function (items) {
                var state = instanceStateMap.get(this);
                var lastTransformation = state.queriesAndTransformations.reduce(function (prev, next) { return isTransformation(next) ? next : prev; }, undefined);
                var itemArray = Array.isArray(items) ? items : [items];
                if (lastTransformation) {
                    var idTransform_1 = lastTransformation.idTransform;
                    if (typeof idTransform_1 === 'string') {
                        return itemArray.map(function (item) { return item[idTransform_1]; });
                    }
                    else {
                        return itemArray.map(idTransform_1);
                    }
                }
                return state.source.identify(items);
            }
        })
    });
    exports.createTrackedQueryTransformResult = createMappedQueryTransformResult
        .mixin({
        mixin: compose_1.default({
            release: function () {
                var state = instanceStateMap.get(this);
                return createMappedQueryTransformResult({
                    isTracking: false,
                    source: state.source,
                    queriesAndTransformations: state.queriesAndTransformations,
                    fetchAroundUpdates: state.fetchAroundUpdates
                });
            }
        })
    });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createMappedQueryTransformResult;
});
//# sourceMappingURL=createQueryTransformResult.js.map