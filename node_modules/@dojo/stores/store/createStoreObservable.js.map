{"version":3,"file":"createStoreObservable.js","sourceRoot":"","sources":["createStoreObservable.ts"],"names":[],"mappings":";;;;;;;;;;IAAA,8CAAyC;IAGzC,4CAAuC;IAEvC,gBAAM,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE,EAAE,OAAO,mBAAA,EAAE,EAAE,CAAC;IASpC,+BAAoD,UAAyB,EAAE,SAA2B;QACzG,oGAAoG;QACpG,aAAa;QACb,IAAM,eAAe,GAAgC,UAAU,CAAC;QAChE,eAAe,CAAC,IAAI,GAAG,UAAY,WAAgF,EAAE,UAAqC;YACzJ,uGAAuG;YACvG,uCAAuC;YACvC,MAAM,CAAC,iBAAO,CAAC,OAAO,CAAC,UAAU,CAAC,SAAS,EAAE,CAAC;iBAC5C,IAAI,CAAC,SAAS,CAAC;iBACf,IAAI,CAAI,WAAW,EAAE,UAAU,CAAC,CAAC;QACpC,CAAC,CAAC;QAEF,eAAe,CAAC,KAAK,GAAG,UAAY,UAAgD;YACnF,MAAM,CAAC,UAAU,CAAC,SAAS,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,CAAI,SAAS,EAAE,UAAU,CAAC,CAAC;QAC9E,CAAC,CAAC;QAEF,MAAM,CAAC,eAAe,CAAC;IACxB,CAAC;;IAjBD,wCAiBC","sourcesContent":["import Promise from '@dojo/shim/Promise';\nimport { Thenable } from '@dojo/interfaces/shim';\nimport { Subscribable, Observable } from '@dojo/core/Observable';\nimport global from '@dojo/core/global';\n\nglobal.Rx = { config: { Promise } };\n\n/**\n * Adds a then method to the observable for those consumers of the store API who\n * only want to know about the end result of an operation, and don't want to deal with\n * any recoverable failures.\n */\nexport type StoreObservable<T, U> = Subscribable<U> & Promise<T[]>\n\nexport default function createStoreObservable<T, U>(observable: Observable<U>, transform: (data: U) => T[]): StoreObservable<T, U> {\n\t// Cast to any because the signatures of catch between the Observable and Promise interfaces are not\n\t// compatible\n\tconst storeObservable: StoreObservable<T, U> = <any> observable;\n\tstoreObservable.then = function<V>(onFulfilled?: ((value: T[]) => (V | Thenable<V> | null | undefined)) | undefined, onRejected?: (reason?: Error) => void): Promise<V> {\n\t\t// Wrap in a shim promise because the interface that leaks through observable.toPromise is missing some\n\t\t// properties on the shim(e.g. promise)\n\t\treturn Promise.resolve(observable.toPromise())\n\t\t\t.then(transform)\n\t\t\t.then<V>(onFulfilled, onRejected);\n\t};\n\n\tstoreObservable.catch = function<U>(onRejected: (reason: Error) => (U | Thenable<U>)): Promise<U> {\n\t\treturn observable.toPromise().then(transform).then<U>(undefined, onRejected);\n\t};\n\n\treturn storeObservable;\n}\n"]}