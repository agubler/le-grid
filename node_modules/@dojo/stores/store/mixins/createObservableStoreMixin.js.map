{"version":3,"file":"createObservableStoreMixin.js","sourceRoot":"","sources":["createObservableStoreMixin.ts"],"names":[],"mappings":"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","sourcesContent":["import createStore, { CrudOptions, Store, StoreOptions, UpdateResults } from '../createStore';\nimport { Observable, Observer } from '@dojo/core/Observable';\nimport WeakMap from '@dojo/shim/WeakMap';\nimport Map from '@dojo/shim/Map';\nimport Set from '@dojo/shim/Set';\nimport Promise from '@dojo/shim/Promise';\nimport { StoreObservable } from '../createStoreObservable';\nimport { ComposeFactory, ComposeMixinDescriptor } from '@dojo/compose/compose';\nimport { after } from '@dojo/compose/aspect';\nimport { Query } from '../../query/interfaces';\nimport { debounce } from '@dojo/core/util';\n\nexport interface StoreDelta<T> {\n\t/**\n\t * Items updated since the last delta\n\t */\n\tupdates: T[];\n\t/**\n\t * The IDs of any deleted items\n\t */\n\tdeletes: string[];\n\t/**\n\t * New items added since the last delta\n\t */\n\tadds: T[];\n\t/**\n\t * The state of the store before any of these updates.\n\t */\n\tbeforeAll: T[];\n\t/**\n\t * The state of the store after all of these updates.  Doesn't necessarily\n\t * reflect the current state of the underlying Storage, as it updates the local\n\t * storage based on the known updates if fetchAroundUpdates is false\n\t */\n\tafterAll: T[];\n}\n\n/**\n * Combines several sequential deltas into a single delta.\n * It performs several checks to remove redundant data.\n * \t- Checks for repeated copies items with the same ID in\n * \tadds and updates, or just the same ID in deletes, and keeps\n * \tonly the last.\n * \t- Checks for deletes followed by adds or updates and replaces with a\n * \tsingle update\n * \t- Checks for adds followed by deletes and removes both\n * \t- Checks for updates followed by deletes and removes the update\n * @param instance The instance that can identify these items\n * @param currentUpdate The current store delta\n * @param newUpdate The new update to merge\n * @returns The merged delta\n */\nexport function mergeDeltas<T>(\n\tinstance: { identify(items: T | T[]): string[] },\n\tcurrentUpdate: StoreDelta<T>,\n\tnewUpdate: StoreDelta<T>\n): StoreDelta<T> {\n\t/**\n\t * Takes the last instance of an item repeated in the list\n\t * @param items Added or updated items\n\t * @returns The added or updated items with repeated items replaced by only the latest version of the item\n\t */\n\tfunction takeLastItem(items: T[]): T[] {\n\t\tconst found: { [ index: string ]: boolean} = {};\n\t\tconst ids = instance.identify(items);\n\t\treturn items.reverse().filter((_, index) => {\n\t\t\tconst id = ids[index];\n\t\t\tconst exists = Boolean(found[id]);\n\t\t\tfound[id] = true;\n\t\t\treturn !exists;\n\t\t}).reverse();\n\t}\n\n\t/**\n\t * Takes the last instance of an id repeated in the list\n\t * @param ids IDs of deleted items\n\t * @returns The list with duplicates removed\n\t */\n\tfunction takeLastId(ids: string[]): string[] {\n\t\tconst found: { [ index: string ]: boolean} = {};\n\t\treturn ids.reverse().filter((id) => {\n\t\t\tconst exists = Boolean(found[id]);\n\t\t\tfound[id] = true;\n\t\t\treturn !exists;\n\t\t}).reverse();\n\t}\n\n\t/**\n\t * Removes updates for items that were later deleted\n\t * @param newDeletes Deletes from delta(s) after the updates\n\t * @param oldUpdates Updates from delta(s) before the deletes\n\t * @return The updates without updates for subsequently deleted items\n\t */\n\tfunction removeOutdatedItems(newDeletes: string[], oldUpdates: T[]) {\n\t\tconst deletedIds = newDeletes.reduce((prev, next) => {\n\t\t\tprev.set(next, null);\n\t\t\treturn prev;\n\t\t}, new Map<string, any>());\n\t\tconst ids = instance.identify(oldUpdates);\n\t\treturn oldUpdates.filter((_, index) => {\n\t\t\treturn !deletedIds.has(ids[index]);\n\t\t});\n\t}\n\n\t/**\n\t * Finds cases where an older update has an add, and a newer update has a delete, and removes\n\t * both, since the net effect is that the operations are cancelled out\n\t * @param newDeletes Deletes form delta(s) after the adds\n\t * @param oldAdds Adds from delta(s) before the deletes\n\t * @returns An object with the filtered adds and deletes\n\t */\n\tfunction removeCancellingUpdates(newDeletes: string[], oldAdds: T[]) {\n\t\tconst deletedIds = newDeletes.reduce((prev, next) => {\n\t\t\tprev.set(next, null);\n\t\t\treturn prev;\n\t\t}, new Map<string, any>());\n\t\tconst ids = instance.identify(oldAdds);\n\t\tconst addIds = ids.reduce((prev, next) => {\n\t\t\tprev.set(next, null);\n\t\t\treturn prev;\n\t\t}, new Map<string, any>());\n\t\treturn {\n\t\t\toldAdds: oldAdds.filter((_, index) => {\n\t\t\t\treturn !deletedIds.has(ids[index]);\n\t\t\t}),\n\t\t\tnewDeletes: newDeletes.filter((id) => !addIds.has(id))\n\t\t};\n\t}\n\n\t/**\n\t * Finds places where an item was deleted and then added or updated, and removes the delete. If the item was added,\n\t * the add is also replaced with an update since it should already exist in the collection receiving the updates,\n\t * as it will never receive the delete\n\t * @param oldDeletes - Deletes from delta(s) before the adds and updates\n\t * @param newAdds - Adds from delta(s) after the deletes\n\t * @param newUpdates - Updates from delta(s) after the deletes\n\t * @returns An object containing the updated deletes, adds, and updates\n\t */\n\tfunction convertReplacementToUpdate(oldDeletes: string[], newAdds: T[], newUpdates: T[]) {\n\t\tconst deletes = oldDeletes.reduce((prev, next) => {\n\t\t\tprev.set(next, null);\n\t\t\treturn prev;\n\t\t}, new Map<string, any>());\n\t\tconst addIds = instance.identify(newAdds);\n\t\tconst updateIds = instance.identify(newUpdates);\n\t\tconst adds = addIds.concat(updateIds).reduce((prev, next) => {\n\t\t\tprev.set(next, null);\n\t\t\treturn prev;\n\t\t}, new Map<string, any>());\n\t\tconst updatedUpdates = newUpdates.slice();\n\t\treturn {\n\t\t\toldDeletes: oldDeletes.filter((id) => !adds.has(id)),\n\t\t\tnewAdds: newAdds.filter((item, index) => {\n\t\t\t\tconst shouldKeep = !deletes.has(addIds[index]);\n\t\t\t\tif (!shouldKeep) {\n\t\t\t\t\t// Always add it to the beginning, because it may have been updated as well, but the add\n\t\t\t\t\t// has to have come first.\n\t\t\t\t\tupdatedUpdates.unshift(item);\n\t\t\t\t}\n\t\t\t\treturn shouldKeep;\n\t\t\t}),\n\t\t\tnewUpdates: updatedUpdates\n\t\t};\n\t}\n\n\tconst { oldDeletes, newAdds, newUpdates } = convertReplacementToUpdate(\n\t\tcurrentUpdate.deletes, newUpdate.adds, newUpdate.updates\n\t);\n\tconst oldUpdates = removeOutdatedItems(newUpdate.deletes, currentUpdate.updates);\n\tconst { newDeletes, oldAdds } = removeCancellingUpdates(newUpdate.deletes, currentUpdate.adds);\n\treturn {\n\t\tupdates: takeLastItem([ ...oldUpdates, ...newUpdates ]),\n\t\tadds: takeLastItem([ ...oldAdds, ...newAdds ]),\n\t\tdeletes: takeLastId([ ...oldDeletes, ...newDeletes ]),\n\t\tbeforeAll: currentUpdate.beforeAll,\n\t\tafterAll: newUpdate.afterAll\n\t};\n}\n\n/**\n * An update for a single item, used to identify which item an update is for when multiple items are observed\n * simultaneously. Deletes are indicated by the item property being undefined.\n */\nexport interface ItemUpdate<T> {\n\titem?: T;\n\tid: string;\n}\n\nexport interface ObservableStoreMixin<T> {\n\t/**\n\t * Observe the entire store, receiving deltas indicating the changes to the store.\n\t * When observing, an initial update will be sent with the last known state of the store in the `afterAll` property.\n\t * If fetchAroundUpdates is true, the store's local data will by synchronized with the underlying Storage.\n\t * If fetchAroundUpdates is not true, then the data will be the result of locally applying updates to the data\n\t * retrieved from the last fetch.\n\t */\n\tobserve(): Observable<StoreDelta<T>>;\n\t/**\n\t * Receives the current state of the item with the specified ID whenever it is updated. This observable will be\n\t * completed if the item is deleted\n\t * @param id The ID of the item to observe\n\t */\n\tobserve(id: string): Observable<T>;\n\t/**\n\t * Receives the current state of the items in an `ItemUpdate` object whenever they are updated. When any of the\n\t * items are deleted an `ItemUpdate` with the item's ID and no item property will be sent out. When all of the\n\t * observed items are deleted the observable will be completed.\n\t * @param ids - The IDS of the items to observe\n\t */\n\tobserve(ids: string[]): Observable<ItemUpdate<T>>;\n}\n\nexport interface ObservableStoreMixinOptions<T> {\n\t/**\n\t * If true, then the local collection will automatically fetch to get the latest data from the store whenver\n\t * an update is made.\n\t */\n\tfetchAroundUpdates?: boolean;\n\t/**\n\t * Specifies how long the fetch around updates should be debounced to avoid rapidly fetching when many updates\n\t * are made within close proximity. Defaults to 200 milliseconds\n\t */\n\tfetchAroundUpdateDebounce?: number;\n}\n\nexport type ObserverSetEntry<T> = { observes: Set<string>; observer: Observer<ItemUpdate<T>> };\n\nexport interface ObservableStoreState<T> {\n\tfetchAroundUpdates: boolean;\n\t/**\n\t * A debounced function called to fetch the latest data and send updates to observers after each crud operation,\n\t * if fetchAroundUpdates is true.\n\t */\n\tfetchAndSendUpdates: (store: ObservableStore<T, any, any>) => void;\n\t/**\n\t * Maps item IDs to observers for that item, or sets of observers. For Single item observers this is a one-to-many\n\t * relationship. For `ObserverSetEntries`, this is a many to many relationship, each item can be observed as a part\n\t * of many sets, and each set is linked to all of the items within it.\n\t */\n\titemObservers: Map<string, (Observer<T> | ObserverSetEntry<T>)[]>;\n\t/**\n\t * All the observers of the store\n\t */\n\tobservers: Observer<StoreDelta<T>>[];\n\t/**\n\t * The single observable provided to all observers of the store\n\t */\n\tstoreObservable: Observable<StoreDelta<T>>;\n\t/**\n\t * Updates currently waiting to be merged and sent\n\t */\n\tqueuedUpdate?: StoreDelta<T>;\n\t/**\n\t * The latest local data\n\t */\n\tlocalData: T[];\n\t/**\n\t * Maps item IDs to indices in `localData`\n\t */\n\tlocalIndex: Map<string, number>;\n\t/**\n\t * When `fetchAroundUpdates` is true, this promise is used to wait for the first fetch before sending out initial\n\t * updates, since `localData` will be out of date as soon as the fetch completes.\n\t */\n\tinitialFetch?: Promise<any>;\n}\n\nexport interface ObservableStore<T, O extends CrudOptions, U extends UpdateResults<T>> extends\n\tObservableStoreMixin<T>, Store<T, O, U> {}\n\nexport type ObservableStoreOptions<T, O extends CrudOptions> = ObservableStoreMixinOptions<T> & StoreOptions<T, O>;\n\nexport interface ObservableStoreFactory extends ComposeFactory<ObservableStore<{}, {}, any>, ObservableStoreOptions<{}, {}>> {\n\t<T extends {}, O extends CrudOptions>(options?: ObservableStoreOptions<T, O>): ObservableStore<T, O, UpdateResults<T>>;\n}\n\nconst instanceStateMap = new WeakMap<ObservableStoreMixin<any>, ObservableStoreState<any>>();\n\n/**\n * Takes a collection of items and creates a new copy modified according to the provided updates. This can be used to\n * attempt to track updates in the local collection when fetching after each update is disabled.\n * @param store\n * @param state\n * @param data\n * @param update\n * @returns A new collection with the modifications specified by the update\n */\nfunction addUpdateDelete<T, O extends CrudOptions, U extends UpdateResults<T>>(\n\tstore: ObservableStore<T, O, U>,\n\tstate: ObservableStoreState<T>,\n\tdata: T[],\n\tupdate: StoreDelta<T>\n) {\n\tconst newData = data.slice();\n\tupdate.adds.forEach((item) => {\n\t\tnewData.push(item);\n\t});\n\n\tstore.identify(update.updates).forEach((id, index) => {\n\t\tif (state.localIndex.has(id)) {\n\t\t\tnewData[state.localIndex.get(id)!] = update.updates[index];\n\t\t}\n\t\telse {\n\t\t\tnewData.push(update.updates[index]);\n\t\t}\n\t});\n\n\tupdate.deletes.sort().reverse().forEach((id) => {\n\t\tif (state.localIndex.has(id)) {\n\t\t\tnewData.splice(state.localIndex.get(id)!, 1);\n\t\t}\n\t});\n\n\treturn newData;\n}\n\n/**\n * Build a map of ids to indices for the provided collection. This requires that the array of IDs is either what\n * the index if for, or that the array of items the IDs represent is in the same order, which is already the case\n * if the IDs were generated using the Store's identify function.\n * @param ids - The IDS to build the index for\n * @returns An index mapping ids to indices\n */\nexport function buildIndex(ids: string[]): Map<string, number> {\n\treturn ids.reduce((map, id, index) => {\n\t\tmap.set(id, index);\n\t\treturn map;\n\t}, new Map<string, number>());\n}\n\n/**\n * Merges the latest queued updates, updates the local data and index based on the latest data,\n * sends out updates to observers, and then removes observers that unsubscribed during the update process from the list\n * of observers. If after is provided, it is assumed that that is the latest data for the store, if it is not provided\n * the local data is updated according to the merged delta and that is used as the new local data.\n * @param store\n * @param after - Optional array of items containing the latest data for the store.\n */\nfunction sendUpdates<T, O extends CrudOptions, U extends UpdateResults<T>>(\n\tstore: ObservableStore<T, O, U>,\n\tafter?: T[]\n) {\n\tconst state = instanceStateMap.get(store);\n\tconst storeDelta = state.queuedUpdate || {\n\t\t\tupdates: [],\n\t\t\tadds: [],\n\t\t\tdeletes: [],\n\t\t\tbeforeAll: [],\n\t\t\tafterAll: []\n\t\t};\n\tstate.queuedUpdate = undefined;\n\tafter = after || addUpdateDelete(store, state, state.localData, storeDelta);\n\n\tstoreDelta.beforeAll = state.localData;\n\tstoreDelta.afterAll = after;\n\tstate.localData = after;\n\tstate.localIndex = buildIndex(store.identify(after));\n\n\tstate.observers.forEach(function(observer) {\n\t\tobserver.next({\n\t\t\tupdates: storeDelta.updates.slice(),\n\t\t\tadds: storeDelta.adds.slice(),\n\t\t\tdeletes: storeDelta.deletes.slice(),\n\t\t\tbeforeAll: storeDelta.beforeAll.slice(),\n\t\t\tafterAll: storeDelta.afterAll.slice()\n\t\t});\n\t});\n}\n\n/**\n * Determines whether this is a single observer or a set entry\n * @param observer\n * @returns {boolean}\n */\nfunction isObserverEntry<T>(observer: Observer<T> | ObserverSetEntry<T>): observer is ObserverSetEntry<T> {\n\treturn (<any> observer).observes instanceof Set;\n}\n\n/**\n * Determines whether this is a single observer or a set entry\n * @param observer\n * @returns {boolean}\n */\nfunction isObserver<T>(observer: Observer<T> | ObserverSetEntry<T>): observer is Observer<T> {\n\treturn !isObserverEntry(observer);\n}\n\n/**\n * Iterates through the provided items and/or IDs and notifies observers. If items is provided, then the\n * observers for that item, and the observers for sets of items that include that are updated. If items is null, then\n * these are delete notifications for observers of multiple items. In this case, no update is sent to individual\n * observers, and observers of sets receive `ItemUpdate` objects with the IDs of the deleted items and an undefined item\n *\n * @param items Items to send updates for, or null if these are delete notifications for item set observers\n * @param ids - IDs of the items, should be in the same order as items\n * @param state\n * @param store\n */\nfunction notifyItemObservers<T, O extends CrudOptions, U extends UpdateResults<T>>(\n\titems: T[] | null,\n\tids: string[],\n\tstate: ObservableStoreState<T>,\n\tstore: ObservableStore<T, O, U>\n) {\n\tfunction notify(id: string, after?: T) {\n\t\tif (state.itemObservers.has(id)) {\n\t\t\tstate.itemObservers.get(id)!.map(function(observerOrEntry): Observer<ItemUpdate<T>> | null {\n\t\t\t\tif (isObserverEntry(observerOrEntry)) {\n\t\t\t\t\treturn observerOrEntry.observer;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}).filter(function(observerEntry) {\n\t\t\t\treturn observerEntry;\n\t\t\t}).forEach(function(observer: Observer<ItemUpdate<T>>) {\n\t\t\t\tobserver.next({\n\t\t\t\t\titem: after,\n\t\t\t\t\tid: id\n\t\t\t\t});\n\t\t\t});\n\t\t\tif (after) {\n\t\t\t\tstate.itemObservers.get(id)!.map(function(observerOrEntry): Observer<T> | null {\n\t\t\t\t\tif (isObserver(observerOrEntry)) {\n\t\t\t\t\t\treturn observerOrEntry;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}).filter(function(observer) {\n\t\t\t\t\treturn observer;\n\t\t\t\t}).forEach(function(observer: Observer<T>) {\n\t\t\t\t\tobserver.next(after);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\tif (items) {\n\t\titems.forEach(function(after: T, index: number) {\n\t\t\tconst id = ids[index] || store.identify(after);\n\t\t\tnotify(id, after);\n\t\t});\n\t}\n\telse {\n\t\tids.forEach(function(id) {\n\t\t\tnotify(id, undefined);\n\t\t});\n\t}\n}\n\n/**\n * Queues the appropriate update and then either starts up a fetch or just triggers sending the updates depending\n * on the `fetchAroundUpdates` property\n * @param state\n * @param store\n * @param updates Updated items\n * @param adds Added items\n * @param deletes Deleted IDs\n */\nfunction sendUpdatesOrFetch<T, O extends CrudOptions, U extends UpdateResults<T>>(\n\tstate: ObservableStoreState<T>,\n\tstore: ObservableStore<T, O, U>,\n\tupdates: T[],\n\tadds: T[],\n\tdeletes: string[]\n) {\n\tconst newUpdate = {\n\t\tupdates: updates,\n\t\tadds: adds,\n\t\tdeletes: deletes,\n\t\tbeforeAll: [],\n\t\tafterAll: []\n\t};\n\tstate.queuedUpdate = state.queuedUpdate ? mergeDeltas(store, state.queuedUpdate, newUpdate) : newUpdate;\n\tif (state.fetchAroundUpdates) {\n\t\tstate.fetchAndSendUpdates(store);\n\t}\n\telse {\n\t\tsendUpdates(store);\n\t}\n}\nfunction createObservableStoreMixin<T, O extends CrudOptions, U extends UpdateResults<T>>(): ComposeMixinDescriptor<\n\tStore<T, O, U>,\n\tCrudOptions,\n\tObservableStoreMixin<T>,\n\tObservableStoreMixinOptions<T>\n> {\n\treturn \t{\n\t\tmixin: {\n\t\t\tobserve(this: ObservableStore<T, O, U>, idOrIds?: string | string[]): any {\n\t\t\t\tif (idOrIds) {\n\t\t\t\t\tconst self = <ObservableStore<T, O, U>> this;\n\t\t\t\t\tconst state = instanceStateMap.get(self);\n\t\t\t\t\tif (Array.isArray(idOrIds)) {\n\t\t\t\t\t\tconst ids = <string[]> idOrIds;\n\n\t\t\t\t\t\tconst idSet = new Set<string>(ids);\n\t\t\t\t\t\tconst observable = new Observable<ItemUpdate<T>>(function subscribe(observer: Observer<ItemUpdate<T>>) {\n\t\t\t\t\t\t\tconst observerEntry: ObserverSetEntry<T> = {\n\t\t\t\t\t\t\t\tobserves: idSet,\n\t\t\t\t\t\t\t\tobserver: observer\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tids.forEach(function(id: string) {\n\t\t\t\t\t\t\t\tif (state.itemObservers.has(id)) {\n\t\t\t\t\t\t\t\t\tstate.itemObservers.get(id)!.push(observerEntry);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstate.itemObservers.set(id, [observerEntry]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst foundIds = new Set<string>();\n\t\t\t\t\t\t\tobserver.next = after(observer.next, (result: any, itemUpdate: ItemUpdate<T>) => {\n\t\t\t\t\t\t\t\tfoundIds.add(itemUpdate.id);\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tself.get(ids).then(function(items: T[]) {\n\t\t\t\t\t\t\t\tif (foundIds.size !== ids.length) {\n\t\t\t\t\t\t\t\t\tconst retrievedIdSet = new Set<string>(self.identify(items));\n\t\t\t\t\t\t\t\t\tlet missingItemIds = ids.filter(id => !retrievedIdSet.has(id));\n\n\t\t\t\t\t\t\t\t\tif (retrievedIdSet.size !== idSet.size || missingItemIds.length) {\n\t\t\t\t\t\t\t\t\t\tobserver.error(new Error(`ID(s) \"${missingItemIds}\" not found in store`));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\titems.forEach((item, index) => observer.next({\n\t\t\t\t\t\t\t\t\t\t\titem: item,\n\t\t\t\t\t\t\t\t\t\t\tid: ids[index]\n\t\t\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn observable;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst id = <string> idOrIds;\n\t\t\t\t\t\treturn new Observable<T>(function subscribe(observer: Observer<T>) {\n\t\t\t\t\t\t\tself.get(id).then(function(item: T) {\n\t\t\t\t\t\t\t\tif (!item) {\n\t\t\t\t\t\t\t\t\tobserver.error(new Error(`ID \"${id}\" not found in store`));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (state.itemObservers.has(id)) {\n\t\t\t\t\t\t\t\t\t\tstate.itemObservers.get(id)!.push(observer);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tstate.itemObservers.set(id, [ observer ]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tobserver.next(item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn instanceStateMap.get(this).storeObservable;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\taspectAdvice: {\n\t\t\tafter: {\n\t\t\t\t/**\n\t\t\t\t * After fetching, sends updates if no query was used. If a custom query was used then the data retrieved\n\t\t\t\t * is not indicative of the local data and can't be used. We shouldn't apply the query locally because we\n\t\t\t\t * have no knowledge of the underlying storage implementation or the amount of data and it may be too much\n\t\t\t\t * data to retrieve or update in memory. If this is the initialFetch, don't update since that update\n\t\t\t\t * will be sent to each subscriber at the time of subscription. If we're not sending updates, still set\n\t\t\t\t * the local data and index to the newly retrieved data.\n\t\t\t\t * @param result\n\t\t\t\t * @param query\n\t\t\t\t * @returns {Promise<T[]>}\n\t\t\t\t */\n\t\t\t\tfetch(this: ObservableStore<T, O, U>, result: Promise<T[]>, query?: Query<T>) {\n\t\t\t\t\tif (!query) {\n\t\t\t\t\t\tresult.then(\n\t\t\t\t\t\t\t(data) => {\n\t\t\t\t\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\t\t\t\t\tif (result !== state.initialFetch) {\n\t\t\t\t\t\t\t\t\tsendUpdates(this, data);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstate.localData = data;\n\t\t\t\t\t\t\t\t\tstate.localIndex = buildIndex(this.identify(data));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// Ignore errors here, they should be handled by the caller not observers\n\t\t\t\t\t\t\t() => {}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * After the put is completed, notify the item observers, and then either queue a fetch to send updates\n\t\t\t\t * if fetchAroundUpdates is true, or just send updates if not.\n\t\t\t\t * @param result\n\t\t\t\t * @returns {StoreObservable<T, any>}\n\t\t\t\t */\n\t\t\t\tput(this: ObservableStore<T, O, U>, result: StoreObservable<T, any>) {\n\t\t\t\t\tresult.then(\n\t\t\t\t\t\t(updatedItems: T[]) => {\n\t\t\t\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\t\t\t\tnotifyItemObservers(updatedItems, [], state, this);\n\t\t\t\t\t\t\tsendUpdatesOrFetch(state, this, updatedItems, [], []);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t// Ignore errors here, they should be handled by the caller not observers\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * After the patch is completed, notify the item observers, and then either queue a fetch to send updates\n\t\t\t\t * if fetchAroundUpdates is true, or just send updates if not.\n\t\t\t\t * @param result\n\t\t\t\t * @returns {StoreObservable<T, any>}\n\t\t\t\t */\n\t\t\t\tpatch(this: ObservableStore<T, O, U>, result: StoreObservable<T, U>) {\n\t\t\t\t\tresult.then(\n\t\t\t\t\t\t(updatedItems: T[]) => {\n\t\t\t\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\t\t\t\tnotifyItemObservers(updatedItems, [], state, this);\n\t\t\t\t\t\t\tsendUpdatesOrFetch(state, this, updatedItems, [], []);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t// Ignore errors here, they should be handled by the caller not observers\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * After the add is completed notify observers. If this is the initial add AND we are fetching around\n\t\t\t\t * updates, then the first update to subscribers will already contain this data, since the initial fetch\n\t\t\t\t * is performed after the initial add. In this case we do not need to send an update. We can tell this\n\t\t\t\t * is the first add because it'll be triggered in the createStore base before the state is created for\n\t\t\t\t * this instance in the mixin's initializer\n\t\t\t\t * @param result\n\t\t\t\t * @returns {StoreObservable<T, U>}\n\t\t\t\t */\n\t\t\t\tadd(this: ObservableStore<T, O, U>, result: StoreObservable<T, U>) {\n\t\t\t\t\tconst isFirstAdd = !instanceStateMap.get(this);\n\n\t\t\t\t\tresult.then(\n\t\t\t\t\t\t(addedItems: T[]) => {\n\t\t\t\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\t\t\t\tif (!isFirstAdd || !state.fetchAroundUpdates) {\n\t\t\t\t\t\t\t\tsendUpdatesOrFetch(state, this, [], addedItems, []);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t// Ignore errors here, they should be handled by the caller not observers\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * After the items are deleted, notify item set observers of the deletion of one of the items they are\n\t\t\t\t * observing, and then complete any observables that need to be completed.\n\t\t\t\t * Completing observables is dones as follows\n\t\t\t\t * \t- For observers of a single item, just complete the observer\n\t\t\t\t * \t- For observers of a set of items\n\t\t\t\t * \t\t- Remove the deleted ID of this item from the set of observed IDs\n\t\t\t\t * \t\t- If there are now no observed IDs for the set, complete the observable\n\t\t\t\t * \t- Remove the item observer entry for the deleted ID\n\t\t\t\t * @param result\n\t\t\t\t * @param ids\n\t\t\t\t * @returns {StoreObservable<string, any>}\n\t\t\t\t */\n\t\t\t\tdelete(this: ObservableStore<T, O, U>, result: StoreObservable<string, any>, ids: string | string[]) {\n\t\t\t\t\tresult.then(\n\t\t\t\t\t\t(deleted: string[]) => {\n\t\t\t\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\t\t\t\tnotifyItemObservers(null, deleted, state, this);\n\t\t\t\t\t\t\tdeleted.forEach(function(id: string) {\n\t\t\t\t\t\t\t\tif (state.itemObservers.has(id)) {\n\t\t\t\t\t\t\t\t\tstate.itemObservers.get(id)!.forEach(function(observerOrEntry) {\n\t\t\t\t\t\t\t\t\t\tif (isObserver(observerOrEntry)) {\n\t\t\t\t\t\t\t\t\t\t\tobserverOrEntry.complete();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tobserverOrEntry.observes.delete(id);\n\t\t\t\t\t\t\t\t\t\t\tif (!observerOrEntry.observes.size) {\n\t\t\t\t\t\t\t\t\t\t\t\tobserverOrEntry.observer.complete();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tstate.itemObservers.delete(id);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tsendUpdatesOrFetch(state, this, [], [], deleted);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t// Ignore errors here, they should be handled by the caller not observers\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tinitialize<T, O extends CrudOptions, U extends UpdateResults<T>>(instance: ObservableStore<T, O, U>, options?: ObservableStoreOptions<T, O>) {\n\t\t\toptions = options || {};\n\t\t\tconst itemObservers = new Map<string, (Observer<T> | ObserverSetEntry<T>)[]>();\n\t\t\tconst storeObservable = new Observable<StoreDelta<T>>(function(this: ObservableStoreMixin<T>, observer: Observer<StoreDelta<T>>) {\n\t\t\t\tconst state = instanceStateMap.get(this);\n\t\t\t\tstate.observers.push(observer);\n\t\t\t\tif (state.initialFetch) {\n\t\t\t\t\tstate.initialFetch.then(() => {\n\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\tupdates: [],\n\t\t\t\t\t\t\tdeletes: [],\n\t\t\t\t\t\t\tadds: [],\n\t\t\t\t\t\t\tbeforeAll: [],\n\t\t\t\t\t\t\tafterAll: state.localData.slice()\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tobserver.next({\n\t\t\t\t\t\tupdates: [],\n\t\t\t\t\t\tdeletes: [],\n\t\t\t\t\t\tadds: [],\n\t\t\t\t\t\tbeforeAll: [],\n\t\t\t\t\t\tafterAll: state.localData.slice()\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn () => {\n\t\t\t\t\tfunction remove(observer: Observer<StoreDelta<any>>) {\n\t\t\t\t\t\tstate.observers.splice(state.observers.indexOf(observer), 1);\n\t\t\t\t\t}\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tremove(observer);\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t}.bind(instance));\n\t\t\tconst state: ObservableStoreState<T> = {\n\t\t\t\tfetchAroundUpdates: Boolean(options.fetchAroundUpdates),\n\t\t\t\tfetchAndSendUpdates: debounce((store: ObservableStore<T, O, U>) => {\n\t\t\t\t\tstore.fetch();\n\t\t\t\t}, options.fetchAroundUpdateDebounce || 20),\n\t\t\t\titemObservers: itemObservers,\n\t\t\t\tobservers: [],\n\t\t\t\tstoreObservable: storeObservable,\n\t\t\t\tlocalData: [],\n\t\t\t\tlocalIndex: new Map<string, number>()\n\t\t\t};\n\t\t\tif (options.fetchAroundUpdates) {\n\t\t\t\tstate.initialFetch = instance.fetch();\n\t\t\t}\n\n\t\t\tinstanceStateMap.set(instance, state);\n\t\t}\n\t};\n}\nexport default createObservableStoreMixin;\n\nexport const createObservableStore: ObservableStoreFactory = createStore\n\t.mixin(createObservableStoreMixin());\n"]}