import { Query } from '../../query/interfaces';
import { Filter } from '../../query/createFilter';
import { StoreRange } from '../../query/createStoreRange';
import { StoreOptions, CrudOptions, UpdateResults } from '../createStore';
import { Sort } from '../../query/createSort';
import { ComposeMixinDescriptor, ComposeFactory } from '@dojo/compose/compose';
import { ObservableStore, ObservableStoreOptions } from './createObservableStoreMixin';
import { Patch } from '../../patch/createPatch';
import { QueryTransformResult, MappedQueryTransformResult } from '../createQueryTransformResult';
export interface QueryTransformMixin<T, S extends ObservableStore<T, any, any>> {
    /**
     * Creates a query transform result with the provided query
     * @param query
     */
    query(query: Query<T>): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;
    /**
     * Creates a query transform result with the provided filter
     * @param filter
     */
    filter(filter: Filter<T>): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;
    /**
     * Creates a query transform result with a filter built from the provided test
     * @param test
     */
    filter(test: (item: T) => boolean): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;
    /**
     * Creates a query transform result with the provided range
     * @param range
     */
    range(range: StoreRange<T>): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;
    /**
     * Creates a query transform result with a range built based on the provided start and count
     * @param start
     * @param cound
     */
    range(start: number, count: number): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;
    /**
     * Creates a query transform result with the provided sort or a sort build from the provided comparator or a
     * comparator for the specified property
     * @param sort
     * @param descending
     */
    sort(sort: Sort<T> | ((a: T, b: T) => number) | string, descending?: boolean): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;
    /**
     * Create a query transform result that cannot be tracked, and cannot send tracked updates. This is the case because
     * the resulting query transform result will have no way to identify items, making it impossible to determine
     * whether their position has shifted or differentiating between updates and adds
     * @param transformation
     */
    transform<V>(transformation: Patch<T, V> | ((item: T) => V)): QueryTransformResult<V, S & QueryTransformMixin<T, S>>;
    /**
     * Create a trackable query transform result with the specified transformation
     * @param transformation
     * @param idTransform
     */
    transform<V>(transformation: Patch<T, V> | ((item: T) => V), idTransform: string | ((item: V) => string)): MappedQueryTransformResult<V, S & QueryTransformMixin<T, S>>;
}
export interface QueryTransformState {
    /**
     * We have to track whether we're fetching around updates because the query transform results need to know this in
     * order to determine whether they can fully trust the data provided to them from the source store's observabel
     */
    fetchAroundUpdates: boolean;
}
/**
 * Check if this is a filter query or just a test function
 * @param filterOrTest
 * @returns {boolean}
 */
export declare function isFilter<T>(filterOrTest: Query<any> | ((item: T) => boolean)): filterOrTest is Filter<T>;
/**
 * Check if this is a sort query or just a comparator
 * @param sortOrComparator
 * @returns {boolean}
 */
export declare function isSort<T>(sortOrComparator: Sort<T> | ((a: T, b: T) => number) | string): sortOrComparator is Sort<T>;
export declare type QueryStore<T, S extends ObservableStore<T, any, any>> = QueryTransformMixin<T, S> & S;
export interface QueryStoreFactory extends ComposeFactory<QueryStore<any, any>, StoreOptions<any, any>> {
    <T, S extends ObservableStore<T, any, any>>(options?: ObservableStoreOptions<T, CrudOptions>): QueryStore<T, S>;
}
export interface SimpleQueryStoreFactory extends ComposeFactory<QueryStore<any, any>, StoreOptions<any, any>> {
    <T>(options?: ObservableStoreOptions<T, CrudOptions>): QueryStore<T, ObservableStore<T, CrudOptions, UpdateResults<T>>>;
}
declare function createQueryTransformMixin<T, S extends ObservableStore<T, any, any>>(): ComposeMixinDescriptor<ObservableStore<T, any, any>, StoreOptions<T, any>, QueryTransformMixin<T, S>, StoreOptions<T, any>>;
export default createQueryTransformMixin;
export declare const createQueryStore: SimpleQueryStoreFactory;
