(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../createStore", "@dojo/core/Observable", "@dojo/shim/WeakMap", "@dojo/shim/Map", "@dojo/shim/Set", "@dojo/compose/aspect", "@dojo/core/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    var createStore_1 = require("../createStore");
    var Observable_1 = require("@dojo/core/Observable");
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var Map_1 = require("@dojo/shim/Map");
    var Set_1 = require("@dojo/shim/Set");
    var aspect_1 = require("@dojo/compose/aspect");
    var util_1 = require("@dojo/core/util");
    /**
     * Combines several sequential deltas into a single delta.
     * It performs several checks to remove redundant data.
     * 	- Checks for repeated copies items with the same ID in
     * 	adds and updates, or just the same ID in deletes, and keeps
     * 	only the last.
     * 	- Checks for deletes followed by adds or updates and replaces with a
     * 	single update
     * 	- Checks for adds followed by deletes and removes both
     * 	- Checks for updates followed by deletes and removes the update
     * @param instance The instance that can identify these items
     * @param currentUpdate The current store delta
     * @param newUpdate The new update to merge
     * @returns The merged delta
     */
    function mergeDeltas(instance, currentUpdate, newUpdate) {
        /**
         * Takes the last instance of an item repeated in the list
         * @param items Added or updated items
         * @returns The added or updated items with repeated items replaced by only the latest version of the item
         */
        function takeLastItem(items) {
            var found = {};
            var ids = instance.identify(items);
            return items.reverse().filter(function (_, index) {
                var id = ids[index];
                var exists = Boolean(found[id]);
                found[id] = true;
                return !exists;
            }).reverse();
        }
        /**
         * Takes the last instance of an id repeated in the list
         * @param ids IDs of deleted items
         * @returns The list with duplicates removed
         */
        function takeLastId(ids) {
            var found = {};
            return ids.reverse().filter(function (id) {
                var exists = Boolean(found[id]);
                found[id] = true;
                return !exists;
            }).reverse();
        }
        /**
         * Removes updates for items that were later deleted
         * @param newDeletes Deletes from delta(s) after the updates
         * @param oldUpdates Updates from delta(s) before the deletes
         * @return The updates without updates for subsequently deleted items
         */
        function removeOutdatedItems(newDeletes, oldUpdates) {
            var deletedIds = newDeletes.reduce(function (prev, next) {
                prev.set(next, null);
                return prev;
            }, new Map_1.default());
            var ids = instance.identify(oldUpdates);
            return oldUpdates.filter(function (_, index) {
                return !deletedIds.has(ids[index]);
            });
        }
        /**
         * Finds cases where an older update has an add, and a newer update has a delete, and removes
         * both, since the net effect is that the operations are cancelled out
         * @param newDeletes Deletes form delta(s) after the adds
         * @param oldAdds Adds from delta(s) before the deletes
         * @returns An object with the filtered adds and deletes
         */
        function removeCancellingUpdates(newDeletes, oldAdds) {
            var deletedIds = newDeletes.reduce(function (prev, next) {
                prev.set(next, null);
                return prev;
            }, new Map_1.default());
            var ids = instance.identify(oldAdds);
            var addIds = ids.reduce(function (prev, next) {
                prev.set(next, null);
                return prev;
            }, new Map_1.default());
            return {
                oldAdds: oldAdds.filter(function (_, index) {
                    return !deletedIds.has(ids[index]);
                }),
                newDeletes: newDeletes.filter(function (id) { return !addIds.has(id); })
            };
        }
        /**
         * Finds places where an item was deleted and then added or updated, and removes the delete. If the item was added,
         * the add is also replaced with an update since it should already exist in the collection receiving the updates,
         * as it will never receive the delete
         * @param oldDeletes - Deletes from delta(s) before the adds and updates
         * @param newAdds - Adds from delta(s) after the deletes
         * @param newUpdates - Updates from delta(s) after the deletes
         * @returns An object containing the updated deletes, adds, and updates
         */
        function convertReplacementToUpdate(oldDeletes, newAdds, newUpdates) {
            var deletes = oldDeletes.reduce(function (prev, next) {
                prev.set(next, null);
                return prev;
            }, new Map_1.default());
            var addIds = instance.identify(newAdds);
            var updateIds = instance.identify(newUpdates);
            var adds = addIds.concat(updateIds).reduce(function (prev, next) {
                prev.set(next, null);
                return prev;
            }, new Map_1.default());
            var updatedUpdates = newUpdates.slice();
            return {
                oldDeletes: oldDeletes.filter(function (id) { return !adds.has(id); }),
                newAdds: newAdds.filter(function (item, index) {
                    var shouldKeep = !deletes.has(addIds[index]);
                    if (!shouldKeep) {
                        // Always add it to the beginning, because it may have been updated as well, but the add
                        // has to have come first.
                        updatedUpdates.unshift(item);
                    }
                    return shouldKeep;
                }),
                newUpdates: updatedUpdates
            };
        }
        var _a = convertReplacementToUpdate(currentUpdate.deletes, newUpdate.adds, newUpdate.updates), oldDeletes = _a.oldDeletes, newAdds = _a.newAdds, newUpdates = _a.newUpdates;
        var oldUpdates = removeOutdatedItems(newUpdate.deletes, currentUpdate.updates);
        var _b = removeCancellingUpdates(newUpdate.deletes, currentUpdate.adds), newDeletes = _b.newDeletes, oldAdds = _b.oldAdds;
        return {
            updates: takeLastItem(oldUpdates.concat(newUpdates)),
            adds: takeLastItem(oldAdds.concat(newAdds)),
            deletes: takeLastId(oldDeletes.concat(newDeletes)),
            beforeAll: currentUpdate.beforeAll,
            afterAll: newUpdate.afterAll
        };
    }
    exports.mergeDeltas = mergeDeltas;
    var instanceStateMap = new WeakMap_1.default();
    /**
     * Takes a collection of items and creates a new copy modified according to the provided updates. This can be used to
     * attempt to track updates in the local collection when fetching after each update is disabled.
     * @param store
     * @param state
     * @param data
     * @param update
     * @returns A new collection with the modifications specified by the update
     */
    function addUpdateDelete(store, state, data, update) {
        var newData = data.slice();
        update.adds.forEach(function (item) {
            newData.push(item);
        });
        store.identify(update.updates).forEach(function (id, index) {
            if (state.localIndex.has(id)) {
                newData[state.localIndex.get(id)] = update.updates[index];
            }
            else {
                newData.push(update.updates[index]);
            }
        });
        update.deletes.sort().reverse().forEach(function (id) {
            if (state.localIndex.has(id)) {
                newData.splice(state.localIndex.get(id), 1);
            }
        });
        return newData;
    }
    /**
     * Build a map of ids to indices for the provided collection. This requires that the array of IDs is either what
     * the index if for, or that the array of items the IDs represent is in the same order, which is already the case
     * if the IDs were generated using the Store's identify function.
     * @param ids - The IDS to build the index for
     * @returns An index mapping ids to indices
     */
    function buildIndex(ids) {
        return ids.reduce(function (map, id, index) {
            map.set(id, index);
            return map;
        }, new Map_1.default());
    }
    exports.buildIndex = buildIndex;
    /**
     * Merges the latest queued updates, updates the local data and index based on the latest data,
     * sends out updates to observers, and then removes observers that unsubscribed during the update process from the list
     * of observers. If after is provided, it is assumed that that is the latest data for the store, if it is not provided
     * the local data is updated according to the merged delta and that is used as the new local data.
     * @param store
     * @param after - Optional array of items containing the latest data for the store.
     */
    function sendUpdates(store, after) {
        var state = instanceStateMap.get(store);
        var storeDelta = state.queuedUpdate || {
            updates: [],
            adds: [],
            deletes: [],
            beforeAll: [],
            afterAll: []
        };
        state.queuedUpdate = undefined;
        after = after || addUpdateDelete(store, state, state.localData, storeDelta);
        storeDelta.beforeAll = state.localData;
        storeDelta.afterAll = after;
        state.localData = after;
        state.localIndex = buildIndex(store.identify(after));
        state.observers.forEach(function (observer) {
            observer.next({
                updates: storeDelta.updates.slice(),
                adds: storeDelta.adds.slice(),
                deletes: storeDelta.deletes.slice(),
                beforeAll: storeDelta.beforeAll.slice(),
                afterAll: storeDelta.afterAll.slice()
            });
        });
    }
    /**
     * Determines whether this is a single observer or a set entry
     * @param observer
     * @returns {boolean}
     */
    function isObserverEntry(observer) {
        return observer.observes instanceof Set_1.default;
    }
    /**
     * Determines whether this is a single observer or a set entry
     * @param observer
     * @returns {boolean}
     */
    function isObserver(observer) {
        return !isObserverEntry(observer);
    }
    /**
     * Iterates through the provided items and/or IDs and notifies observers. If items is provided, then the
     * observers for that item, and the observers for sets of items that include that are updated. If items is null, then
     * these are delete notifications for observers of multiple items. In this case, no update is sent to individual
     * observers, and observers of sets receive `ItemUpdate` objects with the IDs of the deleted items and an undefined item
     *
     * @param items Items to send updates for, or null if these are delete notifications for item set observers
     * @param ids - IDs of the items, should be in the same order as items
     * @param state
     * @param store
     */
    function notifyItemObservers(items, ids, state, store) {
        function notify(id, after) {
            if (state.itemObservers.has(id)) {
                state.itemObservers.get(id).map(function (observerOrEntry) {
                    if (isObserverEntry(observerOrEntry)) {
                        return observerOrEntry.observer;
                    }
                    else {
                        return null;
                    }
                }).filter(function (observerEntry) {
                    return observerEntry;
                }).forEach(function (observer) {
                    observer.next({
                        item: after,
                        id: id
                    });
                });
                if (after) {
                    state.itemObservers.get(id).map(function (observerOrEntry) {
                        if (isObserver(observerOrEntry)) {
                            return observerOrEntry;
                        }
                        else {
                            return null;
                        }
                    }).filter(function (observer) {
                        return observer;
                    }).forEach(function (observer) {
                        observer.next(after);
                    });
                }
            }
        }
        if (items) {
            items.forEach(function (after, index) {
                var id = ids[index] || store.identify(after);
                notify(id, after);
            });
        }
        else {
            ids.forEach(function (id) {
                notify(id, undefined);
            });
        }
    }
    /**
     * Queues the appropriate update and then either starts up a fetch or just triggers sending the updates depending
     * on the `fetchAroundUpdates` property
     * @param state
     * @param store
     * @param updates Updated items
     * @param adds Added items
     * @param deletes Deleted IDs
     */
    function sendUpdatesOrFetch(state, store, updates, adds, deletes) {
        var newUpdate = {
            updates: updates,
            adds: adds,
            deletes: deletes,
            beforeAll: [],
            afterAll: []
        };
        state.queuedUpdate = state.queuedUpdate ? mergeDeltas(store, state.queuedUpdate, newUpdate) : newUpdate;
        if (state.fetchAroundUpdates) {
            state.fetchAndSendUpdates(store);
        }
        else {
            sendUpdates(store);
        }
    }
    function createObservableStoreMixin() {
        return {
            mixin: {
                observe: function (idOrIds) {
                    if (idOrIds) {
                        var self_1 = this;
                        var state_1 = instanceStateMap.get(self_1);
                        if (Array.isArray(idOrIds)) {
                            var ids_1 = idOrIds;
                            var idSet_1 = new Set_1.default(ids_1);
                            var observable = new Observable_1.Observable(function subscribe(observer) {
                                var observerEntry = {
                                    observes: idSet_1,
                                    observer: observer
                                };
                                ids_1.forEach(function (id) {
                                    if (state_1.itemObservers.has(id)) {
                                        state_1.itemObservers.get(id).push(observerEntry);
                                    }
                                    else {
                                        state_1.itemObservers.set(id, [observerEntry]);
                                    }
                                });
                                var foundIds = new Set_1.default();
                                observer.next = aspect_1.after(observer.next, function (result, itemUpdate) {
                                    foundIds.add(itemUpdate.id);
                                    return result;
                                });
                                self_1.get(ids_1).then(function (items) {
                                    if (foundIds.size !== ids_1.length) {
                                        var retrievedIdSet_1 = new Set_1.default(self_1.identify(items));
                                        var missingItemIds = ids_1.filter(function (id) { return !retrievedIdSet_1.has(id); });
                                        if (retrievedIdSet_1.size !== idSet_1.size || missingItemIds.length) {
                                            observer.error(new Error("ID(s) \"" + missingItemIds + "\" not found in store"));
                                        }
                                        else {
                                            items.forEach(function (item, index) { return observer.next({
                                                item: item,
                                                id: ids_1[index]
                                            }); });
                                        }
                                    }
                                });
                            });
                            return observable;
                        }
                        else {
                            var id_1 = idOrIds;
                            return new Observable_1.Observable(function subscribe(observer) {
                                self_1.get(id_1).then(function (item) {
                                    if (!item) {
                                        observer.error(new Error("ID \"" + id_1 + "\" not found in store"));
                                    }
                                    else {
                                        if (state_1.itemObservers.has(id_1)) {
                                            state_1.itemObservers.get(id_1).push(observer);
                                        }
                                        else {
                                            state_1.itemObservers.set(id_1, [observer]);
                                        }
                                        observer.next(item);
                                    }
                                });
                            });
                        }
                    }
                    else {
                        return instanceStateMap.get(this).storeObservable;
                    }
                }
            },
            aspectAdvice: {
                after: {
                    /**
                     * After fetching, sends updates if no query was used. If a custom query was used then the data retrieved
                     * is not indicative of the local data and can't be used. We shouldn't apply the query locally because we
                     * have no knowledge of the underlying storage implementation or the amount of data and it may be too much
                     * data to retrieve or update in memory. If this is the initialFetch, don't update since that update
                     * will be sent to each subscriber at the time of subscription. If we're not sending updates, still set
                     * the local data and index to the newly retrieved data.
                     * @param result
                     * @param query
                     * @returns {Promise<T[]>}
                     */
                    fetch: function (result, query) {
                        var _this = this;
                        if (!query) {
                            result.then(function (data) {
                                var state = instanceStateMap.get(_this);
                                if (result !== state.initialFetch) {
                                    sendUpdates(_this, data);
                                }
                                else {
                                    state.localData = data;
                                    state.localIndex = buildIndex(_this.identify(data));
                                }
                            }, 
                            // Ignore errors here, they should be handled by the caller not observers
                            function () { });
                        }
                        return result;
                    },
                    /**
                     * After the put is completed, notify the item observers, and then either queue a fetch to send updates
                     * if fetchAroundUpdates is true, or just send updates if not.
                     * @param result
                     * @returns {StoreObservable<T, any>}
                     */
                    put: function (result) {
                        var _this = this;
                        result.then(function (updatedItems) {
                            var state = instanceStateMap.get(_this);
                            notifyItemObservers(updatedItems, [], state, _this);
                            sendUpdatesOrFetch(state, _this, updatedItems, [], []);
                        }, 
                        // Ignore errors here, they should be handled by the caller not observers
                        function () { });
                        return result;
                    },
                    /**
                     * After the patch is completed, notify the item observers, and then either queue a fetch to send updates
                     * if fetchAroundUpdates is true, or just send updates if not.
                     * @param result
                     * @returns {StoreObservable<T, any>}
                     */
                    patch: function (result) {
                        var _this = this;
                        result.then(function (updatedItems) {
                            var state = instanceStateMap.get(_this);
                            notifyItemObservers(updatedItems, [], state, _this);
                            sendUpdatesOrFetch(state, _this, updatedItems, [], []);
                        }, 
                        // Ignore errors here, they should be handled by the caller not observers
                        function () { });
                        return result;
                    },
                    /**
                     * After the add is completed notify observers. If this is the initial add AND we are fetching around
                     * updates, then the first update to subscribers will already contain this data, since the initial fetch
                     * is performed after the initial add. In this case we do not need to send an update. We can tell this
                     * is the first add because it'll be triggered in the createStore base before the state is created for
                     * this instance in the mixin's initializer
                     * @param result
                     * @returns {StoreObservable<T, U>}
                     */
                    add: function (result) {
                        var _this = this;
                        var isFirstAdd = !instanceStateMap.get(this);
                        result.then(function (addedItems) {
                            var state = instanceStateMap.get(_this);
                            if (!isFirstAdd || !state.fetchAroundUpdates) {
                                sendUpdatesOrFetch(state, _this, [], addedItems, []);
                            }
                        }, 
                        // Ignore errors here, they should be handled by the caller not observers
                        function () { });
                        return result;
                    },
                    /**
                     * After the items are deleted, notify item set observers of the deletion of one of the items they are
                     * observing, and then complete any observables that need to be completed.
                     * Completing observables is dones as follows
                     * 	- For observers of a single item, just complete the observer
                     * 	- For observers of a set of items
                     * 		- Remove the deleted ID of this item from the set of observed IDs
                     * 		- If there are now no observed IDs for the set, complete the observable
                     * 	- Remove the item observer entry for the deleted ID
                     * @param result
                     * @param ids
                     * @returns {StoreObservable<string, any>}
                     */
                    delete: function (result, ids) {
                        var _this = this;
                        result.then(function (deleted) {
                            var state = instanceStateMap.get(_this);
                            notifyItemObservers(null, deleted, state, _this);
                            deleted.forEach(function (id) {
                                if (state.itemObservers.has(id)) {
                                    state.itemObservers.get(id).forEach(function (observerOrEntry) {
                                        if (isObserver(observerOrEntry)) {
                                            observerOrEntry.complete();
                                        }
                                        else {
                                            observerOrEntry.observes.delete(id);
                                            if (!observerOrEntry.observes.size) {
                                                observerOrEntry.observer.complete();
                                            }
                                        }
                                    });
                                    state.itemObservers.delete(id);
                                }
                            });
                            sendUpdatesOrFetch(state, _this, [], [], deleted);
                        }, 
                        // Ignore errors here, they should be handled by the caller not observers
                        function () { });
                        return result;
                    }
                }
            },
            initialize: function (instance, options) {
                options = options || {};
                var itemObservers = new Map_1.default();
                var storeObservable = new Observable_1.Observable(function (observer) {
                    var state = instanceStateMap.get(this);
                    state.observers.push(observer);
                    if (state.initialFetch) {
                        state.initialFetch.then(function () {
                            observer.next({
                                updates: [],
                                deletes: [],
                                adds: [],
                                beforeAll: [],
                                afterAll: state.localData.slice()
                            });
                        });
                    }
                    else {
                        observer.next({
                            updates: [],
                            deletes: [],
                            adds: [],
                            beforeAll: [],
                            afterAll: state.localData.slice()
                        });
                    }
                    return function () {
                        function remove(observer) {
                            state.observers.splice(state.observers.indexOf(observer), 1);
                        }
                        setTimeout(function () {
                            remove(observer);
                        });
                    };
                }.bind(instance));
                var state = {
                    fetchAroundUpdates: Boolean(options.fetchAroundUpdates),
                    fetchAndSendUpdates: util_1.debounce(function (store) {
                        store.fetch();
                    }, options.fetchAroundUpdateDebounce || 20),
                    itemObservers: itemObservers,
                    observers: [],
                    storeObservable: storeObservable,
                    localData: [],
                    localIndex: new Map_1.default()
                };
                if (options.fetchAroundUpdates) {
                    state.initialFetch = instance.fetch();
                }
                instanceStateMap.set(instance, state);
            }
        };
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createObservableStoreMixin;
    exports.createObservableStore = createStore_1.default
        .mixin(createObservableStoreMixin());
});
//# sourceMappingURL=createObservableStoreMixin.js.map