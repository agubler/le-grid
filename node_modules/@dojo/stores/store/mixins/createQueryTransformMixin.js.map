{"version":3,"file":"createQueryTransformMixin.js","sourceRoot":"","sources":["createQueryTransformMixin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Query, QueryType } from '../../query/interfaces';\nimport createFilter, { Filter } from '../../query/createFilter';\nimport createRange, { StoreRange } from '../../query/createStoreRange';\nimport { StoreOptions, CrudOptions, UpdateResults } from '../createStore';\nimport createSort, { Sort } from '../../query/createSort';\nimport { ComposeMixinDescriptor, ComposeFactory } from '@dojo/compose/compose';\nimport { ObservableStore, createObservableStore, ObservableStoreOptions } from './createObservableStoreMixin';\nimport { Patch } from '../../patch/createPatch';\nimport createMappedQueryTransformResult, { QueryTransformResult, MappedQueryTransformResult, createQueryTransformResult } from '../createQueryTransformResult';\nimport WeakMap from '@dojo/shim/WeakMap';\n\nexport interface QueryTransformMixin<T, S extends ObservableStore<T, any, any>> {\n\t/**\n\t * Creates a query transform result with the provided query\n\t * @param query\n\t */\n\tquery(query: Query<T>): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;\n\t/**\n\t * Creates a query transform result with the provided filter\n\t * @param filter\n\t */\n\tfilter(filter: Filter<T>): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;\n\t/**\n\t * Creates a query transform result with a filter built from the provided test\n\t * @param test\n\t */\n\tfilter(test: (item: T) => boolean): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;\n\t/**\n\t * Creates a query transform result with the provided range\n\t * @param range\n\t */\n\trange(range: StoreRange<T>): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;\n\t/**\n\t * Creates a query transform result with a range built based on the provided start and count\n\t * @param start\n\t * @param cound\n\t */\n\trange(start: number, count: number): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;\n\t/**\n\t * Creates a query transform result with the provided sort or a sort build from the provided comparator or a\n\t * comparator for the specified property\n\t * @param sort\n\t * @param descending\n\t */\n\tsort(sort: Sort<T> | ((a: T, b: T) => number) | string, descending?: boolean): MappedQueryTransformResult<T, S & QueryTransformMixin<T, S>>;\n\t/**\n\t * Create a query transform result that cannot be tracked, and cannot send tracked updates. This is the case because\n\t * the resulting query transform result will have no way to identify items, making it impossible to determine\n\t * whether their position has shifted or differentiating between updates and adds\n\t * @param transformation\n\t */\n\ttransform<V>(transformation: Patch<T, V> | ((item: T) => V)): QueryTransformResult<V, S & QueryTransformMixin<T, S>>;\n\t/**\n\t * Create a trackable query transform result with the specified transformation\n\t * @param transformation\n\t * @param idTransform\n\t */\n\ttransform<V>(transformation: Patch<T, V> | ((item: T) => V), idTransform: string | ((item: V) => string)): MappedQueryTransformResult<V, S & QueryTransformMixin<T, S>>;\n}\n\nexport interface QueryTransformState {\n\t/**\n\t * We have to track whether we're fetching around updates because the query transform results need to know this in\n\t * order to determine whether they can fully trust the data provided to them from the source store's observabel\n\t */\n\tfetchAroundUpdates: boolean;\n}\n/**\n * Check if this is a filter query or just a test function\n * @param filterOrTest\n * @returns {boolean}\n */\nexport function isFilter<T>(filterOrTest: Query<any> | ((item: T) => boolean)): filterOrTest is Filter<T> {\n\treturn typeof filterOrTest !== 'function' && (<Query<any>> filterOrTest).queryType === QueryType.Filter;\n}\n\n/**\n * Check if this is a sort query or just a comparator\n * @param sortOrComparator\n * @returns {boolean}\n */\nexport function isSort<T>(sortOrComparator: Sort<T> | ((a: T, b: T) => number) | string): sortOrComparator is Sort<T> {\n\tconst paramType = typeof sortOrComparator;\n\treturn paramType !== 'function' && paramType !== 'string' && typeof (<Sort<T>> sortOrComparator).apply === 'function';\n}\n\nexport type QueryStore<T, S extends ObservableStore<T, any, any>> = QueryTransformMixin<T, S> & S;\n\nexport interface QueryStoreFactory extends ComposeFactory<QueryStore<any, any>, StoreOptions<any, any>> {\n\t<T, S extends ObservableStore<T, any, any>>(options?: ObservableStoreOptions<T, CrudOptions>): QueryStore<T, S>;\n}\n\nexport interface SimpleQueryStoreFactory extends ComposeFactory<QueryStore<any, any>, StoreOptions<any, any>> {\n\t<T>(options?: ObservableStoreOptions<T, CrudOptions>): QueryStore<T, ObservableStore<T, CrudOptions, UpdateResults<T>>>;\n}\n\nconst instanceStateMap = new WeakMap<any, QueryTransformState>();\n\nfunction createQueryTransformMixin<T, S extends ObservableStore<T, any, any>>(): ComposeMixinDescriptor<\n\tObservableStore<T, any, any>,\n\tStoreOptions<T, any>,\n\tQueryTransformMixin<T, S>,\n\tStoreOptions<T, any>\n> {\n\tconst queryMixin: QueryTransformMixin<T, S> = {\n\t\tquery(this: QueryStore<T, S>, query: Query<T>) {\n\t\t\treturn createMappedQueryTransformResult<T, QueryStore<T, S>>({\n\t\t\t\tsource: this,\n\t\t\t\tqueriesAndTransformations: [ query ],\n\t\t\t\tfetchAroundUpdates: instanceStateMap.get(this).fetchAroundUpdates\n\t\t\t});\n\t\t},\n\n\t\tfilter(this: QueryStore<T, S>, filterOrTest: Filter<T> | ((item: T) => boolean)) {\n\t\t\tlet filter: Filter<T>;\n\t\t\tif (isFilter(filterOrTest)) {\n\t\t\t\tfilter = filterOrTest;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfilter = createFilter<T>().custom(<(item: T) => boolean> filterOrTest);\n\t\t\t}\n\n\t\t\treturn this.query(filter);\n\t\t},\n\n\t\trange(this: QueryStore<T, S>, rangeOrStart: StoreRange<T> | number, count?: number) {\n\t\t\tlet range: StoreRange<T>;\n\t\t\tif (typeof count !== 'undefined') {\n\t\t\t\trange = createRange<T>(<number> rangeOrStart, count);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trange = <StoreRange<T>> rangeOrStart;\n\t\t\t}\n\n\t\t\treturn this.query(range);\n\t\t},\n\n\t\tsort(this: QueryStore<T, S>, sortOrComparator: Sort<T> | ((a: T, b: T) => number), descending?: boolean) {\n\t\t\tlet sort: Sort<T>;\n\t\t\tif (isSort(sortOrComparator)) {\n\t\t\t\tsort = sortOrComparator;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsort = createSort(sortOrComparator, descending);\n\t\t\t}\n\n\t\t\treturn this.query(sort);\n\t\t},\n\n\t\ttransform<V>(this: QueryStore<T, S>, transformation: Patch<T, V> | ((item: T) => V), idTransform?: string | ((item: V) => string)): any {\n\t\t\tconst options = {\n\t\t\t\tsource: this,\n\t\t\t\tqueriesAndTransformations: [ { transformation: transformation, idTransform: idTransform} ],\n\t\t\t\tfetchAroundUpdates: instanceStateMap.get(this).fetchAroundUpdates\n\t\t\t};\n\t\t\tif (idTransform) {\n\t\t\t\treturn createMappedQueryTransformResult<V, QueryStore<T, S>>(options);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn createQueryTransformResult<V, QueryStore<T, S>>(options);\n\t\t\t}\n\t\t}\n\t};\n\treturn \t{\n\t\tmixin: queryMixin,\n\t\tinitialize(instance: QueryStore<T, S>, options?: { fetchAroundUpdates?: boolean}) {\n\t\t\tinstanceStateMap.set(instance, {\n\t\t\t\tfetchAroundUpdates: (options && options.fetchAroundUpdates) || false\n\t\t\t});\n\t\t}\n\t};\n}\n\nexport default createQueryTransformMixin;\n\nexport const createQueryStore: SimpleQueryStoreFactory = createObservableStore\n\t.mixin(createQueryTransformMixin());\n"]}