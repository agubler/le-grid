import { CrudOptions, Store, StoreOptions, UpdateResults } from '../createStore';
import { Observable, Observer } from '@dojo/core/Observable';
import Map from '@dojo/shim/Map';
import Set from '@dojo/shim/Set';
import Promise from '@dojo/shim/Promise';
import { ComposeFactory, ComposeMixinDescriptor } from '@dojo/compose/compose';
export interface StoreDelta<T> {
    /**
     * Items updated since the last delta
     */
    updates: T[];
    /**
     * The IDs of any deleted items
     */
    deletes: string[];
    /**
     * New items added since the last delta
     */
    adds: T[];
    /**
     * The state of the store before any of these updates.
     */
    beforeAll: T[];
    /**
     * The state of the store after all of these updates.  Doesn't necessarily
     * reflect the current state of the underlying Storage, as it updates the local
     * storage based on the known updates if fetchAroundUpdates is false
     */
    afterAll: T[];
}
/**
 * Combines several sequential deltas into a single delta.
 * It performs several checks to remove redundant data.
 * 	- Checks for repeated copies items with the same ID in
 * 	adds and updates, or just the same ID in deletes, and keeps
 * 	only the last.
 * 	- Checks for deletes followed by adds or updates and replaces with a
 * 	single update
 * 	- Checks for adds followed by deletes and removes both
 * 	- Checks for updates followed by deletes and removes the update
 * @param instance The instance that can identify these items
 * @param currentUpdate The current store delta
 * @param newUpdate The new update to merge
 * @returns The merged delta
 */
export declare function mergeDeltas<T>(instance: {
    identify(items: T | T[]): string[];
}, currentUpdate: StoreDelta<T>, newUpdate: StoreDelta<T>): StoreDelta<T>;
/**
 * An update for a single item, used to identify which item an update is for when multiple items are observed
 * simultaneously. Deletes are indicated by the item property being undefined.
 */
export interface ItemUpdate<T> {
    item?: T;
    id: string;
}
export interface ObservableStoreMixin<T> {
    /**
     * Observe the entire store, receiving deltas indicating the changes to the store.
     * When observing, an initial update will be sent with the last known state of the store in the `afterAll` property.
     * If fetchAroundUpdates is true, the store's local data will by synchronized with the underlying Storage.
     * If fetchAroundUpdates is not true, then the data will be the result of locally applying updates to the data
     * retrieved from the last fetch.
     */
    observe(): Observable<StoreDelta<T>>;
    /**
     * Receives the current state of the item with the specified ID whenever it is updated. This observable will be
     * completed if the item is deleted
     * @param id The ID of the item to observe
     */
    observe(id: string): Observable<T>;
    /**
     * Receives the current state of the items in an `ItemUpdate` object whenever they are updated. When any of the
     * items are deleted an `ItemUpdate` with the item's ID and no item property will be sent out. When all of the
     * observed items are deleted the observable will be completed.
     * @param ids - The IDS of the items to observe
     */
    observe(ids: string[]): Observable<ItemUpdate<T>>;
}
export interface ObservableStoreMixinOptions<T> {
    /**
     * If true, then the local collection will automatically fetch to get the latest data from the store whenver
     * an update is made.
     */
    fetchAroundUpdates?: boolean;
    /**
     * Specifies how long the fetch around updates should be debounced to avoid rapidly fetching when many updates
     * are made within close proximity. Defaults to 200 milliseconds
     */
    fetchAroundUpdateDebounce?: number;
}
export declare type ObserverSetEntry<T> = {
    observes: Set<string>;
    observer: Observer<ItemUpdate<T>>;
};
export interface ObservableStoreState<T> {
    fetchAroundUpdates: boolean;
    /**
     * A debounced function called to fetch the latest data and send updates to observers after each crud operation,
     * if fetchAroundUpdates is true.
     */
    fetchAndSendUpdates: (store: ObservableStore<T, any, any>) => void;
    /**
     * Maps item IDs to observers for that item, or sets of observers. For Single item observers this is a one-to-many
     * relationship. For `ObserverSetEntries`, this is a many to many relationship, each item can be observed as a part
     * of many sets, and each set is linked to all of the items within it.
     */
    itemObservers: Map<string, (Observer<T> | ObserverSetEntry<T>)[]>;
    /**
     * All the observers of the store
     */
    observers: Observer<StoreDelta<T>>[];
    /**
     * The single observable provided to all observers of the store
     */
    storeObservable: Observable<StoreDelta<T>>;
    /**
     * Updates currently waiting to be merged and sent
     */
    queuedUpdate?: StoreDelta<T>;
    /**
     * The latest local data
     */
    localData: T[];
    /**
     * Maps item IDs to indices in `localData`
     */
    localIndex: Map<string, number>;
    /**
     * When `fetchAroundUpdates` is true, this promise is used to wait for the first fetch before sending out initial
     * updates, since `localData` will be out of date as soon as the fetch completes.
     */
    initialFetch?: Promise<any>;
}
export interface ObservableStore<T, O extends CrudOptions, U extends UpdateResults<T>> extends ObservableStoreMixin<T>, Store<T, O, U> {
}
export declare type ObservableStoreOptions<T, O extends CrudOptions> = ObservableStoreMixinOptions<T> & StoreOptions<T, O>;
export interface ObservableStoreFactory extends ComposeFactory<ObservableStore<{}, {}, any>, ObservableStoreOptions<{}, {}>> {
    <T extends {}, O extends CrudOptions>(options?: ObservableStoreOptions<T, O>): ObservableStore<T, O, UpdateResults<T>>;
}
/**
 * Build a map of ids to indices for the provided collection. This requires that the array of IDs is either what
 * the index if for, or that the array of items the IDs represent is in the same order, which is already the case
 * if the IDs were generated using the Store's identify function.
 * @param ids - The IDS to build the index for
 * @returns An index mapping ids to indices
 */
export declare function buildIndex(ids: string[]): Map<string, number>;
declare function createObservableStoreMixin<T, O extends CrudOptions, U extends UpdateResults<T>>(): ComposeMixinDescriptor<Store<T, O, U>, CrudOptions, ObservableStoreMixin<T>, ObservableStoreMixinOptions<T>>;
export default createObservableStoreMixin;
export declare const createObservableStore: ObservableStoreFactory;
