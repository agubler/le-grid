{"version":3,"file":"createPatch.js","sourceRoot":"","sources":["createPatch.ts"],"names":[],"mappings":"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","sourcesContent":["import { shouldRecurseInto, isEqual } from '../utils';\nimport createOperation,  { Operation, OperationType } from './createOperation';\nimport createJsonPointer, { JsonPointer } from './createJsonPointer';\nexport interface Patch<T, U> {\n\toperations: Operation[];\n\tapply(target: T): U;\n\ttoString(): String;\n}\n\nexport type PatchMapEntry<T, U> = { id: string; patch: Patch<T, U> };\n\nfunction _diff(to: any, from: any, startingPath?: JsonPointer): Operation[] {\n\tif (!shouldRecurseInto(from) || !shouldRecurseInto(to)) {\n\t\treturn [];\n\t}\n\tconst path = startingPath || createJsonPointer();\n\tconst fromKeys = Object.keys(from);\n\tconst toKeys = Object.keys(to);\n\tconst operations: Operation[] = [];\n\n\tfromKeys.forEach(function(key) {\n\t\tif (!isEqual(from[key], to[key])) {\n\t\t\tif ((key in from) && !(key in to)) {\n\t\t\t\toperations.push(createOperation(OperationType.Remove, path.push(key)));\n\t\t\t}\n\t\t\telse if (shouldRecurseInto(from[key]) && shouldRecurseInto(to[key])) {\n\t\t\t\toperations.push(..._diff(to[key], from[key], path.push(key)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperations.push(createOperation(OperationType.Replace, path.push(key), to[key], undefined, from[key]));\n\t\t\t}\n\t\t}\n\t});\n\n\ttoKeys.forEach(function(key) {\n\t\tif (!(key in from) && (key in to)) {\n\t\t\toperations.push(createOperation(OperationType.Add, path.push(key), to[key]));\n\t\t}\n\t});\n\n\treturn operations;\n}\n\nexport function diff<T>(to: T): Patch<any, T>;\nexport function diff<T, U>(to: U, from: T): Patch<T, U>;\nexport function diff(to: any, from: any = {}) {\n\treturn createPatch(_diff(to, from));\n}\n\nfunction createPatch(operations: Operation[]) {\n\treturn {\n\t\toperations: operations,\n\t\tapply(this: Patch<any, any>, target: any) {\n\t\t\treturn this.operations.reduce((prev: any, next: Operation) => next.apply(prev), target);\n\t\t},\n\t\ttoString(this: Patch<any, any>) {\n\t\t\treturn '[' + this.operations.reduce((prev: string, next: Operation) => {\n\t\t\t\t\tif (prev) {\n\t\t\t\t\t\treturn prev + ',' + next.toString();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn next.toString();\n\t\t\t\t\t}\n\t\t\t\t}, '') + ']';\n\t\t}\n\t};\n}\nexport default createPatch;\n"]}