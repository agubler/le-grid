(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../utils", "./createJsonPointer"], factory);
    }
})(function (require, exports) {
    "use strict";
    var utils_1 = require("../utils");
    var createJsonPointer_1 = require("./createJsonPointer");
    function navigatePath(target, path) {
        var currentPath = '';
        var lastSegment = '';
        var pathSegments = path.segments();
        pathSegments.forEach(function (segment, index) {
            currentPath += "/" + segment;
            if (!target) {
                throw new Error("Invalid path: " + currentPath + " doesn't exist in target");
            }
            else if (index + 1 < pathSegments.length) {
                target = target[segment];
            }
            else {
                lastSegment = segment;
            }
        });
        return {
            object: target,
            property: lastSegment
        };
    }
    function add(target) {
        var applyTo = navigatePath(target, this.path);
        applyTo.object[applyTo.property] = this.value;
        return target;
    }
    function remove(target) {
        var applyTo = navigatePath(target, this.path);
        delete applyTo.object[applyTo.property];
        return target;
    }
    function replace(target) {
        var applyTo = navigatePath(target, this.path);
        if (!(applyTo.property in applyTo.object)) {
            throw new Error("Cannot replace undefined path: " + this.path.toString() + " on object");
        }
        applyTo.object[applyTo.property] = this.value;
        return target;
    }
    function copyOrMove(from, to, target, toDelete) {
        var moveFrom = navigatePath(target, from);
        if (!(moveFrom.property in moveFrom.object)) {
            throw new Error("Cannot move from undefined path: " + from.toString() + " on object");
        }
        var applyTo = navigatePath(target, to);
        applyTo.object[applyTo.property] = moveFrom.object[moveFrom.property];
        if (toDelete) {
            delete moveFrom.object[moveFrom.property];
        }
    }
    function move(target) {
        copyOrMove(this.from, this.path, target, true);
        return target;
    }
    function copy(target) {
        copyOrMove(this.from, this.path, target, false);
        return target;
    }
    function test(target) {
        var applyTo = navigatePath(target, this.path);
        return utils_1.isEqual(applyTo.object[applyTo.property], this.value);
    }
    function getPath(path) {
        if (Array.isArray(path)) {
            return createJsonPointer_1.default.apply(void 0, path);
        }
        else {
            return path;
        }
    }
    function toString() {
        var jsonObj = {};
        jsonObj.op = this.op;
        jsonObj.path = this.path.toString();
        if (this.value) {
            jsonObj.value = this.value;
        }
        if (this.from) {
            jsonObj.from = this.from.toString();
        }
        return JSON.stringify(jsonObj);
    }
    function createOperation(type, path, value, from, oldValue) {
        switch (type) {
            case 0 /* Add */:
                return {
                    op: 'add',
                    path: getPath(path),
                    value: value,
                    apply: add,
                    toString: toString
                };
            case 1 /* Remove */:
                return {
                    op: 'remove',
                    path: getPath(path),
                    apply: remove,
                    toString: toString
                };
            case 2 /* Replace */:
                return {
                    op: 'replace',
                    path: getPath(path),
                    value: value,
                    oldValue: oldValue,
                    apply: replace,
                    toString: toString
                };
            case 4 /* Move */:
                if (!from) {
                    throw new Error('From value is required for Move operations');
                }
                return {
                    op: 'move',
                    path: getPath(path),
                    from: getPath(from),
                    apply: move,
                    toString: toString
                };
            case 3 /* Copy */:
                if (!from) {
                    throw new Error('From value is required in Copy operation');
                }
                return {
                    op: 'copy',
                    path: getPath(path),
                    from: getPath(from),
                    apply: copy,
                    toString: toString
                };
            case 5 /* Test */:
                return {
                    op: 'test',
                    path: getPath(path),
                    value: value,
                    apply: test,
                    toString: toString
                };
        }
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createOperation;
});
//# sourceMappingURL=createOperation.js.map